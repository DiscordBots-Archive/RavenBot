{"meta":{"generator":"0.2.0","format":19,"date":1555007486128},"custom":{"client":{"name":"client","files":{"index":{"name":"raven","type":"js","content":"require('./util/Extensions'); require('dotenv').config();\r\nconst Client = require('./client/Client');\r\nconst Logger = require('./util/Logger');\r\nconst Raven = require('raven');\r\nconst client = new Client({ owner: process.env.OWNER, token: process.env.TOKEN });\r\n\r\nif (process.env.RAVEN) {\r\n\tRaven.config(process.env.RAVEN, {\r\n\t\tcaptureUnhandledRejections: true,\r\n\t\tautoBreadcrumbs: true,\r\n\t\tenvironment: 'Raven',\r\n\t\trelease: '0.1.0'\r\n\t}).install();\r\n}\r\n\r\nclient.on('disconnect', () => Logger.warn('[CLIENT DISCONNECTED]'))\r\n.on('reconnect', () => Logger.info('[CLIENT RECONNECTING]'))\r\n.on('error', err => Logger.error(`[CLIENT ERROR] ${err.message}`))\r\n.on('warn', warn => Logger.warn(`[CLIENT WARN] ${warn}`));\r\n\r\nclient.start();\r\nclient.metrics();\r\n\r\nprocess.on('unhandledRejection', err => {\r\n\tLogger.error(`[UNHANDLED REJECTION] ${err.message}`);\r\n\tLogger.stacktrace(err);\r\n});","path":"src/index.js"},"Client":{"name":"Client","type":"js","content":"const { AkairoClient, CommandHandler, InhibitorHandler, ListenerHandler } = require('discord-akairo');\r\nconst { Counter, collectDefaultMetrics, register } = require('prom-client');\r\nconst SettingsProvider = require('../struct/SettingsProviders');\r\nconst MuteScheduler = require('../struct/MuteScheduler');\r\nconst ReactionRole = require('../models/ReactionRoles');\r\nconst { Client: Lavaqueue } = require('lavaqueue');\r\nconst { Collection, Util } = require('discord.js');\r\nconst Database = require('../struct/Database');\r\nconst Playlist = require('../models/Playlist');\r\nconst Setting = require('../models/settings');\r\nconst { createServer } = require('http');\r\nconst Case = require('../models/Case');\r\nconst { Rejects } = require('rejects');\r\nconst Tags = require('../models/Tags');\r\nconst { Op } = require('sequelize');\r\nconst { parse } = require('url');\r\nconst path = require('path');\r\n\r\nclass Client extends AkairoClient {\r\n\tconstructor(config) {\r\n\t\tsuper({ ownerID: config.owner }, {\r\n\t\t\tmessageCacheMaxSize: 50,\r\n\t\t\tmessageCacheLifetime: 300,\r\n\t\t\tmessageSweepInterval: 900,\r\n\t\t\tdisableEveryone: true,\r\n\t\t\tdisabledEvents: ['TYPING_START']\r\n\t\t});\r\n\r\n\t\tthis.commandHandler = new CommandHandler(this, {\r\n\t\t\tdirectory: path.join(__dirname, '..', 'commands'),\r\n\t\t\taliasReplacement: /-/g,\r\n\t\t\tprefix: message => this.settings.get(message.guild, 'prefix', '*'),\r\n\t\t\tallowMention: true,\r\n\t\t\tfetchMembers: true,\r\n\t\t\tcommandUtil: true,\r\n\t\t\tcommandUtilLifetime: 3e5,\r\n\t\t\tcommandUtilSweepInterval: 9e5,\r\n\t\t\thandleEdits: true,\r\n\t\t\tdefaultCooldown: 3000,\r\n\t\t\tdefaultPrompt: {\r\n\t\t\t\tmodifyStart: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\tmodifyRetry: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\ttimeout: msg => `${msg.author} **::** Time ran out, command has been cancelled.`,\r\n\t\t\t\tended: msg => `${msg.author} **::** Too many retries, command has been cancelled.`,\r\n\t\t\t\tcancel: msg => `${msg.author} **::** Command has been cancelled.`,\r\n\t\t\t\tretries: 2,\r\n\t\t\t\ttime: 30000\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.inhibitorHandler = new InhibitorHandler(this, { directory: path.join(__dirname, '..', 'inhibitors') });\r\n\t\tthis.listenerHandler = new ListenerHandler(this, { directory: path.join(__dirname, '..', 'listeners') });\r\n\r\n\t\tthis.prometheus = {\r\n            messagesCounter: new Counter({ name: 'raven_messages_total', help: 'Total number of messages have seen' }),\r\n            commandCounter: new Counter({ name: 'raven_commands_total', help: 'Total number of commands used' }),\r\n            collectDefaultMetrics,\r\n            register\r\n        };\r\n        this.prometheus.collectDefaultMetrics({ prefix: 'raven_', timeout: 30000 });\r\n\r\n\t\tthis.music = new Lavaqueue({\r\n\t\t\tuserID: process.env.ID,\r\n\t\t\tpassword: process.env.PASS,\r\n\t\t\thosts: {\r\n\t\t\t\trest: process.env.REST,\r\n\t\t\t\tws: process.env.WS,\r\n\t\t\t\tredis: {\r\n\t\t\t\t\tport: process.env.PORT,\r\n\t\t\t\t\thost: process.env.HOST,\r\n\t\t\t\t\tdb: process.env.DB\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsend: async (guild, packet) => {\r\n\t\t\t\tconst shardGuild = this.guilds.get(guild);\r\n\t\t\t\tif (shardGuild) return shardGuild.shard.send(packet);\r\n\t\t\t\treturn Promise.resolve();\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tthis.config = config;\r\n\t\tthis.storage = new Rejects(this.music.queues.redis);\r\n\t\tthis.settings = new SettingsProvider(Setting);\r\n\t\tthis.muteScheduler = new MuteScheduler(this, Case);\r\n\t\tthis.starboards = new Collection();\r\n\t\tthis.cached = new Set();\r\n\r\n\t\tthis.commandHandler.resolver.addType('tag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn tag || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('existingTag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { guildID: message.guild.id,\r\n\t\t\t\t[Op.or]: [\r\n\t\t\t\t\t{ name: phrase },\r\n\t\t\t\t\t{ aliases: { [Op.contains]: [phrase] } }\r\n\t\t\t\t]\r\n\t\t\t}});\r\n\r\n\t\t\treturn tag ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('tagContent', (phrase, message) => {\r\n\t\t\tif (!phrase) phrase = '';\r\n\t\t\tphrase = Util.cleanContent(phrase, message);\r\n\t\t\tif (message.attachments.first()) phrase += `\\n${message.attachments.first().url}`;\r\n\r\n\t\t\treturn phrase || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('reactionRole', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tconst msg = await ReactionRole.findOne({ where: { guildID: message.guild.id, messageID: phrase }});\r\n\t\t\treturn msg || null;\r\n\t\t})\r\n\r\n\t\tthis.commandHandler.resolver.addType('playlist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist || null;\r\n\t\t});\r\n\t\t\r\n\t\tthis.commandHandler.resolver.addType('existingPlaylist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.setup();\r\n\r\n\t\t/*\r\n\t\tsetInterval(() => {\r\n\t\t\tfor (const guild of this.guilds.values()) {\r\n\t\t\t\tguild.presences.clear();\r\n\t\t\t}\r\n\t\t}, 900);\r\n\t\t*/\r\n\t}\r\n\r\n\tasync setup() {\r\n\t\tthis.commandHandler.useInhibitorHandler(this.inhibitorHandler);\r\n\t\tthis.commandHandler.useListenerHandler(this.listenerHandler);\r\n\t\tthis.listenerHandler.setEmitters({\r\n\t\t\tcommandHandler: this.commandHandler,\r\n\t\t\tinhibitorHandler: this.inhibitorHandler,\r\n\t\t\tlistenerHandler: this.listenerHandler\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.loadAll();\r\n\t\tthis.inhibitorHandler.loadAll();\r\n\t\tthis.listenerHandler.loadAll();\r\n\t}\r\n\r\n\tasync metrics() {\r\n\t\tcreateServer((req, res) => {\r\n\t\t\tif (parse(req.url).pathname === '/metrics') {\r\n\t\t\t\tres.writeHead(200, { 'Content-Type': this.prometheus.register.contentType });\r\n\t\t\t\tres.write(this.prometheus.register.metrics());\r\n\t\t\t};\r\n\t\t\tres.end();\r\n\t\t}).listen(8080);\r\n    };\r\n\r\n\tasync start() {\r\n\t\tawait Database.authenticate();\r\n\t\tawait this.settings.init();\r\n\t\treturn this.login(this.config.token);\r\n\t}\r\n}\r\n\r\nmodule.exports = Client;\r\n","path":"src/client/Client.js"}}},"commands":{"name":"commands","files":{"docs":{"name":"docs","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst fetch =  require('node-fetch');\r\nconst qs = require('querystring');\r\n\r\nconst SOURCES = ['stable', 'master', 'rpc', 'commando', 'akairo', 'akairo-master'];\r\n\r\nclass DocsCommand extends Command {\r\n    constructor() {\r\n        super('docs', {\r\n            aliases: ['docs'],\r\n            category: 'docs',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            args: [\r\n                {\r\n                    id: 'query',\r\n                    match: 'rest',\r\n                    type: 'lowercase',\r\n                    prompt: {\r\n                        start: 'what would you like to search?'\r\n                    }\r\n                },\r\n                {\r\n                    id: 'force',\r\n                    match: 'flag',\r\n                    flag: ['--force', '-f']\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Searches discord.js documentation.',\r\n                usage: '<query>',\r\n                examples: ['TextChannel', 'Client', 'ClientUser#setActivity master']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { query, force }) {\r\n\r\n        query = query.split(' ');\r\n\t\t/*let project = 'main';\r\n\t\tlet branch = ['stable', 'master', 'rpc', 'commando'].includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tif (['rpc', 'commando'].includes(branch)) {\r\n\t\t\tproject = branch;\r\n\t\t\tbranch = 'master';\r\n\t\t}\r\n\t\tconst queryString = qs.stringify({ q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/${project}/${branch}/embed?${queryString}`);*/\r\n        const source = SOURCES.includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tconst queryString = qs.stringify({ src: source, q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/v2/embed?${queryString}`);\r\n\t\tconst data = await res.json();\r\n\t\tif (!data) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n        }\r\n        const newData = JSON.stringify(data).replace(/<p>|<\\/p>|<br>|<\\/br>/g, '');\r\n        const oldEmbed = JSON.parse(newData);\r\n        const embed = this.client.util.embed(oldEmbed)//.setColor(0x8387db).setDescription(data.description.replace(/<p>(.+)<\\/p>/g, '$1'))\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = DocsCommand;","path":"src/commands/docs/docs.js"},"npm":{"name":"npm","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst fetch = require('node-fetch');\r\nconst moment = require('moment'); require('moment-duration-format');\r\n\r\nclass NPMCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('npm', {\r\n\t\t\taliases: ['npm', 'npm-package'],\r\n\t\t\tcategory: 'docs',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'pkg',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: message => `${message.author}, what would you like to search for?`\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: pkg => pkg ? encodeURIComponent(pkg.replace(/ /g, '-')) : null\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Responds with information on an NPM package.',\r\n\t\t\t\tusage: '<query>',\r\n\t\t\t\texamples: ['discord.js', 'discord-akairo', 'node-fetch']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { pkg }) {\r\n\r\n\t\tconst res = await fetch(`https://registry.npmjs.com/${pkg}`);\r\n\t\tif (res.status === 404) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n\t\t}\r\n\t\tconst body = await res.json();\r\n\t\tif (body.time === undefined) {\r\n\t\t\treturn message.util.reply('commander of this package decided to unpublish it.');\r\n\t\t}\r\n\t\tconst version = body.versions[body['dist-tags'].latest];\r\n\t\tconst maintainers = this._trimArray(body.maintainers.map(user => user.name).join(', '));\r\n\t\tconst dependencies = version.dependencies ? this._trimArray(Object.keys(version.dependencies)) : '';\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t.setColor(0xCB0000)\r\n\t\t.setAuthor('NPM', 'https://i.imgur.com/ErKf5Y0.png', 'https://www.npmjs.com/')\r\n\t\t.setTitle(body.name)\r\n\t\t.setURL(`https://www.npmjs.com/package/${pkg}`)\r\n\t\t.setDescription(body.description || 'No description.')\r\n\t\t.addField('Version', body['dist-tags'].latest, true)\r\n\t\t.addField('License', body.license || 'None', true)\r\n\t\t.addField('Author', body.author ? body.author.name : '???', true)\r\n\t\t.addField('Creation Date', moment.utc(body.time.created).format('DD-MM-YYYY kk:mm:ss'), true)\r\n\t\t.addField('Modification Date', moment.utc(body.time.modified).format('DD-MM-YYYY kk:mm:ss'), true)\r\n\t\t.addField('Main File', version.main || 'index.js', true)\r\n\t\t.addField('Dependencies', dependencies && dependencies.length ? dependencies.join(', ') : 'None')\r\n\t\t.addField('Maintainers', maintainers);\r\n\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n\t}\r\n\r\n\t_trimArray(arr) {\r\n\t\tif (arr.length > 10) {\r\n\t\t\tconst len = arr.length - 10;\r\n\t\t\tarr = arr.slice(0, 10);\r\n\t\t}\r\n\t\treturn arr;\r\n\t}\r\n}\r\n\r\nmodule.exports = NPMCommand;","path":"src/commands/docs/npm.js"},"mdn":{"name":"mdn","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst fetch = require('node-fetch');\r\nconst qs = require('querystring');\r\nconst Turndown = require('turndown'); // eslint:disable-line\r\n\r\nclass MDNCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('mdn', {\r\n\t\t\taliases: ['mdn', 'mozilla-developer-network'],\r\n\t\t\tcategory: 'docs',\r\n\t\t\tregex: /^(?:mdn,) (.+)/i,\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'query',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: (message) => `${message.author}, what would you like to search for?`\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: query => query ? query.replace(/#/g, '.prototype.') : null\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Searches MDN for your query.',\r\n\t\t\t\tusage: '<query>',\r\n\t\t\t\texamples: ['Map', 'Map#get', 'Map.set']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { query, match }) {\r\n\t\tif (!query && match) query = match[1];\r\n\t\tconst queryString = qs.stringify({ q: query });\r\n\t\tconst res = await fetch(`https://mdn.pleb.xyz/search?${queryString}`);\r\n\t\tconst body = await res.json();\r\n\t\tif (!body.URL || !body.Title || !body.Summary) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n\t\t}\r\n\t\tconst turndown = new Turndown();\r\n\t\tturndown.addRule('hyperlink', {\r\n\t\t\tfilter: 'a',\r\n\t\t\treplacement: (text, node) => `[${text}](https://developer.mozilla.org${node.href})`\r\n\t\t});\r\n\t\tconst summary = body.Summary.replace(/<code><strong>(.+)<\\/strong><\\/code>/g, '<strong><code>$1<\\/code><\\/strong>');\r\n\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t.setColor(0x066FAD)\r\n\t\t.setAuthor('MDN', 'https://i.imgur.com/DFGXabG.png', 'https://developer.mozilla.org/')\r\n\t\t.setURL(`https://developer.mozilla.org${body.URL}`)\r\n\t\t.setTitle(body.Title)\r\n\t\t.setDescription(turndown.turndown(summary));\r\n\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n\t}\r\n}\r\n\r\nmodule.exports = MDNCommand;","path":"src/commands/docs/mdn.js"},"about":{"name":"guide","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Akairo = require('discord-akairo');\r\nconst Discord = require('discord.js');\r\nconst fs = require('fs');\r\n\r\nclass AboutCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('about', {\r\n\t\t\taliases: ['about', 'info'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Shows information about the bot.' }\r\n\t\t});\r\n\t}\r\n\r\n\texec(message) {\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst owner = this.client.users.get(this.client.ownerID);\r\n\t\tconst raven = fs.readFileSync('file.txt', 'utf8');\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0x8387db)\r\n\t\t\t.setTitle(`About ${this.client.user.username}`)\r\n\t\t\t.addField('Dev', `**${this.client.user.username}** is developed by **[${owner.tag}](https://almostsuvajit.xyz)**`)\r\n\t\t\t.addField('Core', `[Discord.js](https://discord.js.org) (${Discord.version}) library and [Akairo](https://1computer1.github.io/discord-akairo) (${Akairo.version.replace(/beta.1/g, 'dev')}) framework`)\r\n\t\t\t.addField('Music', `[Lavalink](https://github.com/lavalibs/lavalink.js) audio player, along with [Lavaqueue](https://github.com/lavalibs/lavaqueue), backed by [Redis](https://github.com/MicrosoftArchive/redis) instance`)\r\n\t\t\t.addField('Database', `[PostgreSQL](https://www.postgresql.org/) database, along with [Sequelize](http://docs.sequelizejs.com/) [Node.js](https://nodejs.org/en/) ORM`)\r\n\t\t\t.addField('Host', [\r\n\t\t\t\t`[Amazon EC2](https://aws.amazon.com/ec2/)`,\r\n\t\t\t\t'```js',\r\n\t\t\t\t`${raven.toString()}`,\r\n\t\t\t\t'```'\r\n\t\t\t])\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = AboutCommand;\r\n","path":"src/commands/general/about.js"},"blacklist":{"name":"blacklist","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass BlacklistCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('blacklist', {\r\n\t\t\taliases: ['blacklist', 'unblacklist'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tuserPermissions: ['MANAGE_GUILD'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Which user do you want to blacklist or unblacklist?',\r\n\t\t\t\t\t\tretry: 'Please provide a valid user.'\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Blacklists or unblacklists someone from using stars and giving reputation.',\r\n\t\t\t\tusage: '<user>',\r\n\t\t\t\texamples: ['@BadPerson', 'someone#1234']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { member }) {\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\r\n\t\tif (blacklist.includes(member.id)) {\r\n\t\t\tconst index = blacklist.indexOf(member.id);\r\n\t\t\tblacklist.splice(index, 1);\r\n\t\t\tawait this.client.settings.set(message.guild, 'blacklist', blacklist);\r\n\r\n\t\t\treturn message.util.send(`**${member.user.tag}** has been removed from the blacklist.`);\r\n\t\t}\r\n\t\tblacklist.push(member.id);\r\n\t\tawait this.client.settings.set(message.guild, 'blacklist', blacklist);\r\n\r\n\t\treturn message.util.send(`**${member.user.tag}** has been blacklisted from using the starboard and giving reputation on this server.`);\r\n\t}\r\n}\r\n\r\nmodule.exports = BlacklistCommand;","path":"src/commands/general/blacklist.js"},"help":{"name":"help","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass HelpCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('help', {\r\n\t\t\taliases: ['help'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'command',\r\n\t\t\t\t\ttype: 'commandAlias',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Which command do you need help with?',\r\n\t\t\t\t\t\tretry: 'Please provide a valid command.',\r\n\t\t\t\t\t\toptional: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Displays a list of commands or information about a command.',\r\n\t\t\t\tusage: '[command]',\r\n\t\t\t\texamples: ['', 'star', 'remove-rep']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, { command }) {\r\n\t\tif (!command) return this.execCommandList(message);\r\n\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst description = Object.assign({\r\n\t\t\tcontent: 'No description available.',\r\n\t\t\tusage: '',\r\n\t\t\texamples: [],\r\n\t\t\tfields: []\r\n\t\t}, command.description);\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor('#8387db')\r\n\t\t\t.setTitle(`\\`${prefix}${command.aliases[0]} ${description.usage}\\``)\r\n\t\t\t.addField('Description', description.content);\r\n\r\n\t\tfor (const field of description.fields) embed.addField(field.name, field.value);\r\n\r\n\t\tif (description.examples.length) {\r\n\t\t\tconst text = `${prefix}${command.aliases[0]}`;\r\n\t\t\tembed.addField('Examples', `\\`${text} ${description.examples.join(`\\`\\n\\`${text} `)}\\``, true);\r\n\t\t}\r\n\r\n\t\tif (command.aliases.length > 1) {\r\n\t\t\tembed.addField('Aliases', `\\`${command.aliases.join('` `')}\\``, true);\r\n\t\t}\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n\r\n\tasync execCommandList(message) {\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor('#8387db')\r\n\t\t\t.addField('Command List', [\r\n\t\t\t\t`To view details for a command, do \\`*help <command>\\``\r\n\t\t\t]);\r\n\r\n\t\tfor (const category of this.handler.categories.values()) {\r\n\t\t\tconst title = {\r\n\t\t\t\tgeneral: '\\u2000General',\r\n\t\t\t\treputation: '\\u2000Reputation',\r\n\t\t\t\tstarboard: '\\u2000Starboard',\r\n\t\t\t\tdocs: '\\u2000Docs',\r\n\t\t\t\tinfo: '\\u2000Info',\r\n\t\t\t\ttags: '\\u200bTags',\r\n\t\t\t\tmusic: '\\u200bMusic',\r\n\t\t\t\tmod: '\\u200bMod',\r\n\t\t\t\tconfig: '\\u200bConfig',\r\n\t\t\t\tfun: '\\u200bFun'\r\n\t\t\t}[category.id];\r\n\r\n\t\t\tif (title) embed.addField(title, `${category.filter(cmd => cmd.aliases.length > 0).map(cmd => `\\`${cmd.aliases[0]}\\``).join(' ')}`);\r\n\t\t}\r\n\r\n\t\tconst shouldReply = message.guild && message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES');\r\n\r\n\t\ttry {\r\n\t\t\tawait message.author.send({ embed });\r\n\t\t\tif (shouldReply) return message.util.reply('I\\'ve sent you a DM with the command list.');\r\n\t\t} catch (err) {\r\n\t\t\tif (shouldReply) return message.util.reply('I could not send you the command list in DMs.');\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nmodule.exports = HelpCommand;","path":"src/commands/general/help.js"},"invite":{"name":"invite","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass InviteCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('invite', {\r\n\t\t\taliases: ['invite'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Gets the bot invite link.' }\r\n\t\t});\r\n\t}\r\n\r\n\tasync fetchInvite() {\r\n\t\tif (this.invite) return this.invite;\r\n\t\tconst invite = await this.client.generateInvite([\r\n\t\t\t'ADMINISTRATOR',\r\n\t\t\t'VIEW_CHANNEL',\r\n\t\t\t'MANAGE_MESSAGES',\r\n\t\t\t'READ_MESSAGE_HISTORY',\r\n\t\t\t'SEND_MESSAGES',\r\n\t\t\t'EMBED_LINKS'\r\n\t\t]);\r\n\r\n\t\tthis.invite = invite;\r\n\t\treturn invite;\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0xFFAC33)\r\n\t\t\t.setTitle(`**Invite ${this.client.user.username} to your server!**`).setURL(`${await this.fetchInvite()}`);\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = InviteCommand;","path":"src/commands/general/invite.js"},"ping":{"name":"ping","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nconst RESPONSES = [\r\n\t'No...',\r\n\t'Not Happening...',\r\n\t'Maybe Later...',\r\n\t`Pong! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Just you know, I'm not doing this for fun! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Don't think this means anything special! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Can we get on with this already? \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``\r\n];\r\n\r\nclass PingCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('ping', {\r\n\t\t\taliases: ['ping', 'pong'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tdescription: { content: `Pings me!` }\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst msg = await message.util.send('Pinging...');\r\n\r\n\t\treturn message.util.send(\r\n\t\t\tRESPONSES[Math.floor(Math.random() * RESPONSES.length)]\r\n\t\t\t.replace('$(ping)', ((msg.editedTimestamp || msg.createdTimestamp) - (message.editedTimestamp || message.createdTimestamp)).toString())\r\n\t\t\t.replace('$(heartbeat)', Math.round(this.client.ws.ping).toString())\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = PingCommand;","path":"src/commands/general/ping.js"},"prefix":{"name":"prefix","type":"js","content":"const { Argument, Command, Control } = require('discord-akairo');\r\n\r\nclass PrefixCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('prefix', {\r\n\t\t\taliases: ['prefix'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'method',\r\n\t\t\t\t},\r\n\t\t\t\tControl.if((msg, args) => msg.member.roles.has(this.client.settings.get(msg.guild, 'modRole', undefined)) && args.method, [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: 'prefix',\r\n\t\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\t\ttype: Argument.validate('string', p => !/\\s/.test(p) && p.length <= 5),\r\n\t\t\t\t\t\tdefault: '',\r\n\t\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\t\tretry: `Please provide a prefix without spaces and less than 5 characters`\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t])\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: [\r\n\t\t\t\t\t'Displays or changes the prefix of the guild.',\r\n\t\t\t\t\t'The prefix must not contain spaces and be below 5 characters.'\r\n\t\t\t\t],\r\n\t\t\t\tusage: '<prefix>',\r\n\t\t\t\texamples: ['!', '?']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { prefix }) {\r\n\r\n\t\tif (!prefix) return message.util.send(`The current prefix for this guild is: \\`${this.handler.prefix(message)}\\``);\r\n\t\tthis.client.settings.set(message.guild, 'prefix', prefix);\r\n\t\tif (prefix === this.handler.prefix(message)) {\r\n\t\t\treturn message.util.reply(`the prefix has been reset to \\`${prefix}\\``);\r\n\t\t}\r\n\t\treturn message.util.reply(`the prefix has been set to \\`${prefix}\\``);\r\n\t}\r\n}\r\n\r\nmodule.exports = PrefixCommand;","path":"src/commands/general/prefix.js"},"reset":{"name":"reset","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Reputation = require('../../models/reputations');\r\n\r\nclass ResetCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('reset', {\r\n\t\t\taliases: ['reset'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tuserPermissions: ['MANAGE_GUILD'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'mode',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: [['stars', 'star'], ['reps', 'rep'], 'all'],\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Please choose an item to reset: `stars`, `reps`, `all`.',\r\n\t\t\t\t\t\tretry: [\r\n\t\t\t\t\t\t\t'Please provide a valid reset item.',\r\n\t\t\t\t\t\t\t'Choose one of `stars`, `reps` or `all`.'\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'confirm',\r\n\t\t\t\t\tmatch: 'none',\r\n\t\t\t\t\ttype: phrase => {\r\n\t\t\t\t\t\tif (!phrase) return null;\r\n\r\n\t\t\t\t\t\t// Yes, yea, ye, or y.\r\n\t\t\t\t\t\tif (/^y(?:e(?:a|s)?)?$/i.test(phrase)) return true;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: (msg, { mode }) => `${{\r\n\t\t\t\t\t\t\tstars: 'Are you sure you want to reset all stars on this server? (y/N)',\r\n\t\t\t\t\t\t\treps: 'Are you sure you want to reset all reputation points on this server? (y/N)',\r\n\t\t\t\t\t\t\tall: 'Are you sure you want to reset all stars and reputation points on this server? (y/N)'\r\n\t\t\t\t\t\t}[mode]}`,\r\n\t\t\t\t\t\tretry: ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Resets the stars and/or reputations of the guild.',\r\n\t\t\t\tusage: '<mode>',\r\n\t\t\t\texamples: ['stars', 'reps', 'all']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { mode, confirm }) {\r\n\t\tif (!confirm) {\r\n\t\t\treturn message.util.send('Reset has been cancelled.');\r\n\t\t}\r\n\r\n\t\tif (mode === 'stars' || mode === 'all') await this.client.starboards.get(message.guild.id).destroy();\r\n\t\tif (mode === 'reps' || mode === 'all') await Reputation.destroy({ where: { guildID: message.guild.id } });\r\n\r\n\t\treturn message.util.send(`${message.author} **::** ${{\r\n\t\t\tstars: 'Successfully removed all starred messages on this server.',\r\n\t\t\treps: 'Successfully removed all reputation points on this server.',\r\n\t\t\tall: 'Successfully removed all starred messages and reputation points on this server.'\r\n\t\t}[mode]}`);\r\n\t}\r\n}\r\n\r\nmodule.exports = ResetCommand;","path":"src/commands/general/reset.js"},"settings":{"name":"settings","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst ReactionRole = require('../../models/ReactionRoles');\r\n\r\nclass SettingsCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('settings', {\r\n\t\t\taliases: ['settings', 'view-settings'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Displays the guild\\'s current settings.' }\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst starboard = this.client.starboards.get(message.guild.id);\r\n\t\tconst guildlog = this.client.settings.get(message.guild, 'guildLog', undefined);\r\n\t\tconst modlog = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tconst memberlog = this.client.settings.get(message.guild, 'memberLog', undefined);\r\n\t\tconst modrole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\r\n\t\tconst toBeDeleted = await ReactionRole.findAll({ where: { guildID: message.guild.id }});\r\n\t\tfor (const channel of toBeDeleted) {\r\n\t\t\tif (!this.client.channels.has(channel.channelID)) {\r\n\t\t\t\tawait ReactionRole.destroy({ where: { guildID: message.guild.id, channelID: channel.channelID }});\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst allReaction = await ReactionRole.findAll({ where: { guildID: message.guild.id }});\r\n\t\tconst data = await Promise.all(allReaction.map(async row => {\r\n\t\t\tconst channel = await this.client.channels.get(row.channelID);\r\n\t\t\tconst msg = await channel.messages.fetch(row.messageID).catch(() => ( { msg: row.messageID } ));\r\n\t\t\treturn { channel: channel, message: msg, emoji: row.emoji, role: row.roleID };\r\n\t\t}))\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0xFFAC33)\r\n\t\t\t.setTitle('Settings')\r\n\t\t\t.setDescription([\r\n\t\t\t\t`**Prefix**: \\`${prefix}\\``,\r\n\t\t\t\t`**Starboard**: ${(starboard && starboard.channel) || 'None'}`,\r\n\t\t\t\t`**GuildLog**: ${message.guild.channels.get(guildlog) || 'None'}`,\r\n\t\t\t\t`**ModLog**: ${message.guild.channels.get(modlog) || 'None'}`,\r\n\t\t\t\t`**MemberLog**: ${message.guild.channels.get(memberlog) || 'None'}`,\r\n\t\t\t\t`**Mod Role**: ${message.guild.roles.get(modrole) || 'None'}`,\r\n\t\t\t\t`**Moderation**: ${this.client.settings.get(message.guild, 'moderation', undefined)}`,\r\n\t\t\t\t`**Role State**: ${this.client.settings.get(message.guild, 'roleState', undefined)}`,\r\n\t\t\t\t`**Threshold**: ${(starboard && starboard.threshold) || 'None'}`,\r\n\t\t\t\t`**Blacklist**: ${blacklist.join(', ') || 'None'}`\r\n\t\t\t]);\r\n\t\tif (data.length) {\r\n\t\t\tconst desc = data.map(({ channel, message, emoji, role }, index) => `${1 + index}. \\\\${emoji} ${message.url ? `[Jump To](${message.url}) ${channel} <@&${role}>` : `${message.msg} (msg deleted)` }`)\r\n\t\t\tembed.addField('Reaction Roles', desc)\r\n\t\t}\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = SettingsCommand;","path":"src/commands/general/settings.js"},"stats":{"name":"stats","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst os = require('os-utils');\r\nconst moment = require('moment'); require('moment-duration-format');\r\nconst { version } = require('../../../package.json');\r\n\r\nclass StatsCommand extends Command {\r\n    constructor() {\r\n        super('stats', {\r\n            aliases: ['stats'],\r\n            category: 'general',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            ratelimit: 2,\r\n            description: { content: 'Displays statistics about the bot' }\r\n        });\r\n    }\r\n\r\n    async exec(message) {\r\n        const embed = new MessageEmbed().setColor('#8387db').setTitle(`${this.client.user.username} Statistics`)\r\n        .setThumbnail(this.client.user.displayAvatarURL())\r\n        .setURL(`http://raven.almostsuvajit.xyz/metrics`)\r\n        .addField(\"❯ Memory Usage\", [\r\n            `• Using : ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} MB`,\r\n            `• Free : ${Math.round(os.freemem())} MB`\r\n        ], true) \r\n        .addField(\"❯ Uptime\", `• ${moment.duration(this.client.uptime).format(\"M [months], W [weeks], D [days], H [hrs], m [mins], s [secs]\")}`, true)\r\n        .addField(\"❯ General Stats\", [\r\n            `• Users : ${this.client.users.size}`,\r\n            `• Channels : ${this.client.channels.size}`\r\n        ], true)\r\n        .addField('❯ Version', `• [v${version}](https://github.com/isuvajit/raven)`, true)\r\n        .addField(\"❯ Library\", `• [discord.js](https://discord.js.org)[-akairo](https://github.com/discord-akairo/discord-akairo)`, true)\r\n        .setFooter('© 2018 ' + this.client.users.get(this.client.ownerID).tag, this.client.users.get(this.client.ownerID).displayAvatarURL())\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n        const msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = StatsCommand;","path":"src/commands/general/stats.js"},"uptime":{"name":"uptime","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment'); require('moment-duration-format');\r\n\r\nclass UptimeCommand extends Command {\r\n    constructor() {\r\n        super('uptime', {\r\n            aliases: ['uptime'],\r\n            category: 'general',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            description: {\r\n                content: 'Displayes uptime of the bot.'\r\n            }\r\n        })\r\n    }\r\n\r\n    exec(message) {\r\n        const duration = moment.duration(this.client.uptime).format(\"M [months], W [weeks], D [days], H [hrs], m [mins], s [secs]\");\r\n        const embed = this.client.util.embed()\r\n        .setAuthor(duration).setColor(0x8387db)\r\n        \r\n        return message.util.send({ embed });\r\n    }\r\n}\r\n\r\nmodule.exports = UptimeCommand;","path":"src/commands/general/uptime.js"},"avatar":{"name":"avatar","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass AvatarCommand extends Command {\r\n    constructor() {\r\n        super('avatar', {\r\n            aliases: ['avatar'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'member',\r\n                    type: 'member',\r\n                    default: message => message.member\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Displays avatar of a member.',\r\n                usage: '<member>',\r\n                examples: ['@Suvajit', 'Suvajit', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { member }) {\r\n\r\n        const embed = this.client.util.embed().setColor('RANDOM')\r\n        .setAuthor(member.user.tag)\r\n        .setImage(member.user.avatarURL({ size: 2048 }))\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n            msg.reactions.removeAll();\r\n            \r\n\t\t\treturn message;\r\n\t\t}\r\n        react.first().message.delete();\r\n        \r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = AvatarCommand;","path":"src/commands/info/avatar.js"},"channel":{"name":"channel","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nclass ChannelInfoCommand extends Command {\r\n    constructor() {\r\n        super('channelinfo', {\r\n            aliases: ['channel', 'channel-info'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS', 'MANAGE_CHANNELS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'channel',\r\n                    type: 'channel',\r\n                    default: message => message.channel\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a channel.',\r\n                usage: '<channel>',\r\n                examples: ['#general', 'bot-commands', '544374591305285632']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { channel }) {\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`#${channel.name} (${channel.id})`)\r\n        .setThumbnail(message.guild.iconURL())\r\n        .addField('❯ Info', [\r\n            `${channel.topic ? `• Topic: ${channel.topic}` : ''}`,\r\n            `• Type: ${channel.type.toUpperCase()}`,\r\n            `• NSFW: ${channel.nsfw ? 'Yes' : 'No'}`,\r\n            `• Creation Date: ${moment(channel.createdAt).format('D-MM-YY, k:mm:ss')}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = ChannelInfoCommand;","path":"src/commands/info/channel.js"},"emoji":{"name":"emoji-restrict","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass RestrictEmojiCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('restrict-emoji', {\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what member do you want to restrict?`,\r\n\t\t\t\t\t\tretry: `please mention a member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Restrict a members ability to use custom emoji.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: []\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst restrictRoles = this.client.settings.get(message.guild, 'restrictRoles', undefined);\r\n\t\tif (!restrictRoles) return message.reply('there are no restricted roles configured on this server.');\r\n\r\n\t\tconst key = `${message.guild.id}:${member.id}:EMOJI`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\tawait member.roles.add(restrictRoles.emoji, `Embed restricted by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error emoji restricting this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Emoji restriction', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.EMOJI);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.EMOJI,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully emoji restricted **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = RestrictEmojiCommand;","path":"src/commands/mod/emoji.js"},"roleinfo":{"name":"role-info","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nconst PERMISSIONS = ({\r\n    ADMINISTRATOR: 'Administrator',\r\n    VIEW_AUDIT_LOG: 'View Audit Log',\r\n    MANAGE_GUILD: 'Manage Server',\r\n    MANAGE_ROLES: 'Manage Roles',\r\n    MANAGE_CHANNELS: 'Manage Channels',\r\n    KICK_MEMBERS: 'Kick Members',\r\n    BAN_MEMBERS: 'Ban Members',\r\n    CREATE_INSTANT_INVITE: 'Create Instant Invite',\r\n    CHANGE_NICKNAME: 'Change Nickname',\r\n    MANAGE_NICKNAMES: 'Manage Nicknames',\r\n    MANAGE_EMOJIS: 'Manage Emojis',\r\n    MANAGE_WEBHOOKS: 'Manage Webhooks',\r\n    VIEW_CHANNEL: 'Read Text & See Voice Channels',\r\n    SEND_MESSAGES: 'Send Messages',\r\n    SEND_TTS_MESSAGES: 'Send TTS Messages',\r\n    MANAGE_MESSAGES: 'Manage Messages',\r\n    EMBED_LINKS: 'Embed Links',\r\n    ATTACH_FILES: 'Attach Files',\r\n    READ_MESSAGE_HISTORY: 'Read Message History',\r\n    MENTION_EVERYONE: 'Mention Everyone',\r\n    USE_EXTERNAL_EMOJIS: 'Use External Emojis',\r\n    ADD_REACTIONS: 'Add Reactions',\r\n    CONNECT: 'Connect',\r\n    SPEAK: 'Speak',\r\n    MUTE_MEMBERS: 'Mute Members',\r\n    DEAFEN_MEMBERS: 'Deafen Members',\r\n    MOVE_MEMBERS: 'Move Members',\r\n    USE_VAD: 'Use Voice Activity'\r\n})\r\n\r\nclass RoleInfoCommad extends Command {\r\n    constructor() {\r\n        super('roleinfo', {\r\n            aliases: ['roleinfo'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'role',\r\n                    type: 'role',\r\n                    default: message => message.member.roles.highest\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a role.',\r\n                usage: '<role>',\r\n                examples: ['Admin', '@Staff', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { role }) {\r\n\r\n        const permissions = Object.keys(PERMISSIONS).filter(permission => role.permissions.serialize()[permission]);\r\n        const permission = permissions.map(permission => `• ${PERMISSIONS[permission]}`).join('\\n')\r\n\r\n        const embed = this.client.util.embed().setColor(role.hexColor)\r\n        .setAuthor(`${role.name} (${role.id})`)\r\n        .addField('❯ Info', [\r\n            `• Color: ${role.hexColor.toUpperCase()}`,\r\n            `• Hoisted: ${role.hoist ? 'Yes' : 'No'}`,\r\n            `• Mentionable: ${role.mentionable ? 'Yes' : 'No'}`,\r\n            `• Creation Date: ${moment.utc(role.createdAt).format('DD-MM-YY kk:mm:ss')}`\r\n        ])\r\n        .addField('❯ Permissions', `${permission.length === 487 ? '• Administrator' : permission || '• None' }`)\r\n        .setThumbnail(message.guild.iconURL())\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    } \r\n}\r\n\r\nmodule.exports = RoleInfoCommad;","path":"src/commands/info/roleinfo.js"},"server":{"name":"server","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nconst HUMAN_LEVELS = ({\r\n\t0: 'None',\r\n\t1: 'Low',\r\n\t2: 'Medium',\r\n\t3: '(╯°□°）╯︵ ┻━┻',\r\n\t4: '┻━┻ ﾐヽ(ಠ益ಠ)ノ彡┻━┻'\r\n});\r\n\r\nclass ServerInfoCommand extends Command {\r\n    constructor() {\r\n        super('serverinfo', {\r\n            aliases: ['serverinfo', 'server', 'guild'],\r\n            category: 'info',\r\n            channel: 'guild',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            description: { content: 'Get info on the server.' },\r\n        })\r\n    }\r\n\r\n    async exec(message) {\r\n        const members = await message.guild.members.fetch();\r\n\t\tconst bot = members.filter(m => m.user.bot).size;\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`${message.guild.name} (${message.guild.id})`, message.guild.iconURL())\r\n        .setThumbnail(message.guild.iconURL())\r\n        .addField('❯ General Info', [\r\n            `• Members: ${message.guild.memberCount}`,\r\n            `• Bots: ${bot}`,\r\n            `• Roles: ${message.guild.roles.size}`\r\n        ])\r\n        .addField('❯ Channels Info', [\r\n            `• Text: ${message.guild.channels.filter(ch => ch.type === 'text').size}`,\r\n            `• Voice: ${message.guild.channels.filter(ch => ch.type === 'voice').size}`,\r\n            `• AFK: ${message.guild.afkChannelID ? `<#${message.guild.afkChannelID}> after ${message.guild.afkTimeout / 60} min` : 'None'}`\r\n        ])\r\n        .addField('❯ Other', [\r\n            `• Region: ${message.guild.region.toUpperCase()}`,\r\n            `• Created at: ${moment.utc(message.guild.createdAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Owner: ${message.guild.owner.user.tag} (${message.guild.ownerID})`,\r\n            `• Verification Level: ${HUMAN_LEVELS[message.guild.verificationLevel]}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = ServerInfoCommand;","path":"src/commands/info/server.js"},"userinfo":{"name":"user","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nclass UserCommand extends Command {\r\n    constructor() {\r\n        super('user', {\r\n            aliases: ['user'],\r\n            category: 'info',\r\n            channel: 'guild',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            args: [\r\n                {\r\n                    id: 'member',\r\n                    type: 'member',\r\n                    default: message => message.member\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a member.',\r\n                usage: '<member>',\r\n                examples: ['@Suvajit', 'Suvajit', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { member }) {\r\n\r\n        const { user } = member;\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`${member.user.tag} (${member.user.id})`, user.displayAvatarURL())\r\n        .setThumbnail(user.displayAvatarURL())\r\n        .addField('❯ Member Details', [\r\n            `${member.nickname ? `• Nickname: ${member.nickname}` : ''}`,\r\n            `• Joined at: ${moment.utc(member.joinedAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Role: ${member.roles.map(role=> `*${role}*`).join(', ')}`\r\n        ])\r\n        .addField('❯ User Details', [\r\n            `${user.bot ? `• Bot Account` : ''}`,\r\n            `• ID: ${user.id}`,\r\n            `• Created at: ${moment.utc(user.createdAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Status: ${user.presence.status.toUpperCase()}`,\r\n            `• Activity: ${user.presence.activity ? user.presence.activity.name : 'None'}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = UserCommand;","path":"src/commands/info/userinfo.js"},"ban":{"name":"ban","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass BanCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('ban', {\r\n\t\t\taliases: ['ban'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES', 'EMBED_LINKS'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what member do you want to ban?`,\r\n\t\t\t\t\t\tretry: `please mention a valid member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'days',\r\n\t\t\t\t\ttype: 'integer',\r\n\t\t\t\t\tmatch: 'option',\r\n\t\t\t\t\tflag: ['--days', '-d'],\r\n\t\t\t\t\tdefault: 7\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Bans a member, duh.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: ['@Suvajit', '444432489818357760']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, days, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) {\r\n\t\t\ttry {\r\n\t\t\t\tconst done = await member.kick(`${message.author.tag} used a mod command on themselves.`);\r\n\t\t\t\tif (done) {\r\n\t\t\t\t\tawait message.reply('you asked for it, ok?');\r\n\t\t\t\t\tawait member.send('you asked for it, ok?');\r\n\t\t\t\t}\r\n\t\t\t} catch {} // eslint:disable-line\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\t\tconst key = `${message.guild.id}:${member.id}:BAN`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst cases = await Case.findAll({ where: { targetID: member.id, guildID: message.guild.id }});\r\n\t\tconst embed = Base.historyEmbed({member, cases});\r\n\t\tawait message.channel.send('You sure you want me to ban this [no gender specified]?', {embed});\r\n\t\tconst responses = await message.channel.awaitMessages(msg => msg.author.id === message.author.id, {\r\n\t\t\tmax: 1,\r\n\t\t\ttime: 10000\r\n\t\t});\r\n\r\n\t\tif (!responses || responses.size !== 1) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply('timed out. Cancelled ban.');\r\n\t\t}\r\n\t\tconst response = responses.first();\r\n\r\n\t\tlet sentMessage;\r\n\t\tif (/^y(?:e(?:a|s)?)?$/i.test(response.content)) {\r\n\t\t\tsentMessage = await message.channel.send(`Banning **${member.user.tag}**...`);\r\n\t\t} else {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply('cancelled ban.');\r\n\t\t}\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\ttry {\r\n\t\t\t\tawait member.send([\r\n\t\t\t\t\t`**You have been banned from ${message.guild.name}**`,\r\n\t\t\t\t\t`${reason ? `\\n**Reason:** ${reason}\\n` : ''}`,\r\n\t\t\t\t\t`You can appeal your ban by DMing \\`SUVAJIT#5580\\` with a message why you think you deserve to have your ban lifted.`\r\n\t\t\t\t]);\r\n\t\t\t} catch {} // eslint:disable-line\r\n\t\t\tawait member.ban({ days, reason: `Banned by ${message.author.tag} | Case #${totalCases}` });\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error banning this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Ban', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.BAN);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.BAN,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn sentMessage.edit(`Successfully banned **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = BanCommand;","path":"src/commands/mod/ban.js"},"kick":{"name":"kick","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass KickCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('kick', {\r\n\t\t\taliases: ['kick'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: message => `what member do you want to kick?`,\r\n\t\t\t\t\t\tretry: message => `please mention a member...`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Kicks a member, duh.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: ['@Suvajit userbot', '444432489818357760 nsfw']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\tlet sentMessage;\r\n\t\ttry {\r\n\t\t\tsentMessage = await message.channel.send(`Kicking **${member.user.tag}**...`);\r\n\t\t\tawait member.kick(`Kicked by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t\ttry {\r\n\t\t\t\tawait member.send([\r\n\t\t\t\t\t`**You have been kicked from ${message.guild.name}**`,\r\n\t\t\t\t\t`${reason ? `\\n**Reason:** ${reason}\\n` : ''}`,\r\n\t\t\t\t\t`You may rejoin whenever.`\r\n\t\t\t\t]);\r\n\t\t\t} catch {} // eslint:disable-line\r\n\t\t} catch (error) {\r\n\t\t\treturn message.reply('I could not kick this user.');\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Kick', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.KICK);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.KICK,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn sentMessage.edit(`Successfully kicked **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = KickCommand;","path":"src/commands/mod/kick.js"},"mute":{"name":"mute","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst ms = require('ms');\r\n\r\nclass MuteCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('mute', {\r\n\t\t\taliases: ['mute'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Mutes a member, duh.',\r\n\t\t\t\tusage: '<member> <duration> <...reason>',\r\n\t\t\t\texamples: ['@Crawl']\r\n\t\t\t},\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what member do you want to mute?`,\r\n\t\t\t\t\t\tretry: `please mention a member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'duration',\r\n\t\t\t\t\ttype: str => {\r\n\t\t\t\t\t\tif (!str) return null;\r\n\t\t\t\t\t\tconst duration = ms(str);\r\n\t\t\t\t\t\tif (duration && duration >= 300000 && !isNaN(duration)) return duration;\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `for how long do you want the mute to last?`,\r\n\t\t\t\t\t\tretry: `please use a proper time format.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, duration, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst muteRole = this.client.settings.get(message.guild, 'muteRole', undefined);\r\n\t\tif (!muteRole) return message.reply('there is no mute role configured on this server.');\r\n\r\n\t\tconst key = `${message.guild.id}:${member.id}:MUTE`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\tawait member.roles.add(muteRole, `Muted by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error muting this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Mute', duration, caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.MUTE);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait this.client.muteScheduler.addMute({\r\n\t\t\tmessageID: modMessage ? modMessage.id : null,\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.MUTE,\r\n\t\t\taction_duration: new Date(Date.now() + duration),\r\n\t\t\taction_processed: false,\r\n\t\t\treason: reason\r\n\t\t})\r\n\r\n\t\treturn message.util.send(`Successfully muted **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = MuteCommand;","path":"src/commands/mod/mute.js"},"duration":{"name":"duration","type":"js","content":"const { Command, Argument } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst ms = require('ms');\r\n\r\nclass DurationCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('duration', {\r\n\t\t\taliases: ['duration'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Sets the duration for a mute and reschedules it.',\r\n\t\t\t\tusage: '<case> <duration>',\r\n\t\t\t\texamples: ['1234 30m', 'latest 20h']\r\n\t\t\t},\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'caseNum',\r\n\t\t\t\t\ttype: Argument.union('number', 'string'),\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what case do you want to add a reason to?`,\r\n\t\t\t\t\t\tretry: `please enter a case number.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'duration',\r\n\t\t\t\t\ttype: str => {\r\n\t\t\t\t\t\tif (!str) return null;\r\n\t\t\t\t\t\tconst duration = ms(str);\r\n\t\t\t\t\t\tif (duration && duration >= 300000 && !isNaN(duration)) return duration;\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `for how long do you want the mute to last?`,\r\n\t\t\t\t\t\tretry: `please use a proper time format.`\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t]\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { caseNum, duration }) {\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0);\r\n\t\tconst caseToFind = caseNum === 'latest' || caseNum === 'l' ? totalCases : caseNum;\r\n\t\tif (isNaN(caseToFind)) return message.reply('at least provide me with a correct number.');\r\n\t\tconst dbCase = await Case.findOne({ where: { caseID: caseToFind, guildID: message.guild.id, action: Base.CONSTANTS.ACTIONS.MUTE, action_processed: false }});\r\n\t\tif (!dbCase) {\r\n\t\t\treturn message.reply('I couldn\\'t find a case with that Id!');\r\n\t\t}\r\n\t\tif (dbCase.mod_id !== message.author.id && !message.member.permissions.has('MANAGE_GUILD')) {\r\n\t\t\treturn message.reply('you\\'d be wrong in thinking I would let you fiddle with other peoples achievements!');\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst caseEmbed = await (this.client.channels.get(modLogChannel)).messages.fetch(dbCase.messageID);\r\n\t\t\tif (!caseEmbed) return message.reply('looks like the message doesn\\'t exist anymore!');\r\n\t\t\tconst embed = new MessageEmbed(caseEmbed.embeds[0]);\r\n\t\t\tif (dbCase.action_duration) {\r\n\t\t\t\tembed.setDescription(caseEmbed.embeds[0].description.replace(/\\*\\*Length:\\*\\* (.+)*/, `**Length:** ${ms(duration, { long: true })}`));\r\n\t\t\t} else {\r\n\t\t\t\tembed.setDescription(caseEmbed.embeds[0].description.replace(/(\\*\\*Action:\\*\\* Mute)/, `$1\\n**Length:** ${ms(duration, { long: true })}`));\r\n\t\t\t}\r\n\t\t\tawait caseEmbed.edit(embed);\r\n\t\t}\r\n\t\t\r\n\t\tawait Case.update({\r\n\t\t\taction_duration: new Date(Date.now() + duration),\r\n\t\t\tcreatedAt: new Date(Date.now())\r\n\t\t}, { where: { caseID: caseToFind, guildID: message.guild.id }});\r\n\r\n\t\tawait this.client.muteScheduler.rescheduleMute({\r\n\t\t\tmessageID: dbCase.messageID,\r\n\t\t\tcaseID: caseToFind,\r\n\t\t\ttargetID: dbCase.targetID,\r\n\t\t\ttargetTag: dbCase.targetTag,\r\n\t\t\tauthorID: dbCase.authorID,\r\n\t\t\tguildID: dbCase.guildID,\r\n\t\t\tauthorTag: dbCase.authorTag,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.MUTE,\r\n\t\t\taction_duration: new Date(Date.now() + duration),\r\n\t\t\taction_processed: dbCase.action_processed,\r\n\t\t\treason: dbCase.reason\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully updated duration for case **#${caseToFind}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = DurationCommand;","path":"src/commands/mod/duration.js"},"softban":{"name":"softban","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass SoftbanCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('softban', {\r\n\t\t\taliases: ['softban'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what member do you want to softban?`,\r\n\t\t\t\t\t\tretry: `please mention a member...`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Softbans a member, duh.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: ['@Suvajit userbot', '444432489818357760 spam']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst keys = [`${message.guild.id}:${member.id}:BAN`, `${message.guild.id}:${member.id}:UNBAN`];\r\n\t\tif (this.client.cached.has(keys[0]) && this.client.cached.has(keys[1])) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(keys[0]);\r\n\t\tthis.client.cached.add(keys[1]);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\tlet sentMessage;\r\n\t\ttry {\r\n\t\t\tsentMessage = await message.channel.send(`Softbanning **${member.user.tag}**...`);\r\n\t\t\tawait member.ban({ days: 1, reason: `Softbanned by ${message.author.tag} | Case #${totalCases}` });\r\n\t\t\tawait message.guild.members.unban(member, `Softbanned by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t\ttry {\r\n\t\t\t\tawait member.send([\r\n\t\t\t\t\t`**You have been softbanned from ${message.guild.name}**`,\r\n\t\t\t\t\t`${reason ? `\\n**Reason:** ${reason}\\n` : ''}`,\r\n\t\t\t\t\t`A softban is a kick that uses ban + unban to remove your messages from the server.`,\r\n\t\t\t\t\t`You may rejoin whenever.`\r\n\t\t\t\t]);\r\n\t\t\t} catch {} // eslint:disable-line\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(keys[0]);\r\n\t\t\tthis.client.cached.delete(keys[1]);\r\n\t\t\treturn message.reply(`there was an error softbanning this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Softban', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.SOFTBAN);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.SOFTBAN,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn sentMessage.edit(`Successfully softbanned **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = SoftbanCommand;","path":"src/commands/mod/softban.js"},"cybernuke":{"name":"cybernuke","type":"js","content":"const { Command, Argument } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass LaunchCybernukeCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('cybernuke', {\r\n\t\t\taliases: ['cybernuke', 'launch-cybernuke'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\townerOnly: true,\r\n\t\t\tclientPermissions: ['BAN_MEMBERS'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'join',\r\n\t\t\t\t\ttype: Argument.range('number', 0.1, 120, true),\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `how old (in minutes) should a member be for the cybernuke to ignore them (server join date)?`,\r\n\t\t\t\t\t\tretry: `the minimum is \\`0.1\\` and the maximum \\`120\\` minutes.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'age',\r\n\t\t\t\t\ttype: Argument.range('number', 0.1, Infinity, true),\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `how old (in minutes) should a member's account be for the cybernuke to ignore them (account age)?`,\r\n\t\t\t\t\t\tretry: `the minimum is \\`0.1\\` minutes.`\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Bans all members that have joined recently, with new accounts.',\r\n\t\t\t\tusage: '<join> <age>',\r\n\t\t\t\texamples: ['10 120']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { join, age }) {\r\n\t\tawait message.util.send('Calculating targeting parameters for cybernuke...');\r\n\t\tawait message.guild.members.fetch();\r\n\r\n\t\tconst memberCutoff = Date.now() - (join * 60000);\r\n\t\tconst ageCutoff = Date.now() - (age * 60000);\r\n\t\tconst members = message.guild.members.filter(\r\n\t\t\tmember => member.joinedTimestamp > memberCutoff && member.user.createdTimestamp > ageCutoff\r\n\t\t);\r\n\r\n\t\tawait message.util.send(`Cybernuke will strike ${members.size} members; proceed?`);\r\n\t\tlet statusMessage;\r\n\r\n\t\tconst responses = await message.channel.awaitMessages(msg => msg.author.id === message.author.id, {\r\n\t\t\tmax: 1,\r\n\t\t\ttime: 10000\r\n\t\t});\r\n\r\n\t\tif (!responses || responses.size !== 1) {\r\n\t\t\tawait message.reply('Cybernuke cancelled.');\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst response = responses.first();\r\n\r\n\t\tif (/^y(?:e(?:a|s)?)?$/i.test(response.content)) {\r\n\t\t\tstatusMessage = await response.reply('Launching cybernuke...');\r\n\t\t} else {\r\n\t\t\tawait response.reply('Cybernuke cancelled.');\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tconst fatalities = [];\r\n\t\tconst survivors = [];\r\n\t\tconst promises = [];\r\n\r\n\t\tfor (const member of members.values()) {\r\n\t\t\tpromises.push(\r\n\t\t\t\tmember.send([\r\n\t\t\t\t\t`Sorry, but you've been automatically targetted by the cybernuke in the \"${message.guild.name}\" server.`,\r\n\t\t\t\t\t`This means that you have been banned, likely in the case of a server raid.`,\r\n\t\t\t\t\t`Please contact them if you believe this ban to be in error.`\r\n\t\t\t\t]).catch(error => Logger.error(`[CYBERNUKE ERROR] ${error.message}`, { tag: 'Cybernyke' }))\r\n\t\t\t\t.then(async () => member.ban())\r\n\t\t\t\t.then(() => {\r\n\t\t\t\t\tfatalities.push(member);\r\n\t\t\t\t})\r\n\t\t\t\t.catch(err => {\r\n\t\t\t\t\tLogger.error(`[CYBERNUKE ERROR] ${err.message}`, { tag: 'Cybernuke' });\r\n\t\t\t\t\tsurvivors.push({\r\n\t\t\t\t\t\tmember,\r\n\t\t\t\t\t\terror: err\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t\t.then(async () => {\r\n\t\t\t\t\tif (members.size <= 5) return;\r\n\t\t\t\t\tif (promises.length % 5 === 0) {\r\n\t\t\t\t\t\tawait statusMessage.edit(`Launching cyber nuke (${Math.round(promises.length / members.size * 100)}%)...`);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tawait Promise.all(promises);\r\n\t\tawait statusMessage.edit('Cybernuke impact confirmed. Casuality report incoming...');\r\n\t\tawait response.reply([\r\n\t\t\t'',\r\n\t\t\t`**Fatalities**`,\r\n\t\t\t`${fatalities.length > 0 ? `${fatalities.length} confirmed. \\n${fatalities.map(fat => `**-** ${fat.displayName} (${fat.id})`).join('\\n')}` : 'None'}`,\r\n\t\t\t'',\r\n\t\t\t`${survivors.length > 0 ? `**Survivors** \\n${survivors.length} left standing. \\n${survivors.map(srv => `**-** ${srv.member.displayName} (${srv.member.id}): \\`${srv.error}\\``).join('\\n')}` : ''}`\r\n\t\t], { split: true });\r\n\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\nmodule.exports = LaunchCybernukeCommand;","path":"src/commands/mod/cybernuke.js"},"unban":{"name":"unban","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass UnbanCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('unban', {\r\n\t\t\taliases: ['unban'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'user',\r\n\t\t\t\t\ttype: async id => {\r\n\t\t\t\t\t\tconst user = await this.client.users.fetch(id);\r\n\t\t\t\t\t\treturn user;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what member do you want to unban?`,\r\n\t\t\t\t\t\tretry: `please mention a member...`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Unbans a user, duh.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: ['@Suvajit', '444432489818357760']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { user, reason }) {\r\n\t\tif (user.id === message.author.id) return;\r\n\r\n\t\tconst key = `${message.guild.id}:${user.id}:UNBAN`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\tawait message.guild.members.unban(user, `Unbanned by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error unbanning this user: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member: user, action: 'Unban', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.UNBAN);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.UNBAN,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully unbanned **${user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = UnbanCommand;","path":"src/commands/mod/unban.js"},"warn":{"name":"warn","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass WarnCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('warn', {\r\n\t\t\taliases: ['warn'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `What member do you want to warn?`,\r\n\t\t\t\t\t\tretry: `Please mention a valid member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Warns a user, duh.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: ['@Suvajit dumb', '444432489818357760 nsfw']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Warn', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.WARN);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\twarn: 1,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.WARN,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully warned **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = WarnCommand;","path":"src/commands/mod/warn.js"},"restrict":{"name":"restrict","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass RestrictCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('restrict', {\r\n\t\t\taliases: ['restrict'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'restriction',\r\n\t\t\t\t\ttype: ['embed', 'embeds', 'image', 'images', 'img', 'emoji', 'reaction', 'react']\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'rest',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent:[\r\n\t\t\t\t\t'Restrict a members ability to post embeds/use custom emojis/react.',\r\n\t\t\t\t\t'Available restrictions:',\r\n\t\t\t\t\t'• embed \\`<member> <...reason>\\`',\r\n\t\t\t\t\t'• emoji \\`<member> <...reason>\\`',\r\n\t\t\t\t\t'• reaction \\`<member> <...reason>\\`',\r\n\r\n\t\t\t\t\t'Required: \\`<>\\` | Optional: \\`[]\\`',\r\n\r\n\t\t\t\t\t'For additional \\`<...arguments>\\` usage refer to the examples below.'\r\n\t\t\t\t],\r\n\t\t\t\tusage: '<restriction> <...argumens>',\r\n\t\t\t\texamples: [\r\n\t\t\t\t\t'img @Suvajit nsfw',\r\n\t\t\t\t\t'embed @Supriyo img spam',\r\n\t\t\t\t\t'emoji @Nuke dumb',\r\n\t\t\t\t\t'reaction @Riday why though'\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { restriction, rest }) {\r\n\t\tif (!restriction) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treturn message.util.send([\r\n\t\t\t\t`Check \\`${prefix}help restrict\\` for more information.`\r\n\t\t\t]);\r\n\t\t}\r\n\t\tconst command = ({\r\n\t\t\tembed: this.handler.modules.get('restrict-embed'),\r\n\t\t\tembeds: this.handler.modules.get('restrict-embed'),\r\n\t\t\timage: this.handler.modules.get('restrict-embed'),\r\n\t\t\timages: this.handler.modules.get('restrict-embed'),\r\n\t\t\timg: this.handler.modules.get('restrict-embed'),\r\n\t\t\temoji: this.handler.modules.get('restrict-emoji'),\r\n\t\t\treaction: this.handler.modules.get('restrict-reaction'),\r\n\t\t\treact: this.handler.modules.get('restrict-reaction')\r\n\t\t})[restriction];\r\n\r\n\t\treturn this.handler.handleDirectCommand(message, rest, command, true);\r\n\t}\r\n}\r\n\r\nmodule.exports = RestrictCommand;","path":"src/commands/mod/restrict.js"},"embed":{"name":"embed-restrict","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass RestrictEmbedCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('restrict-embed', {\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: message => `what member do you want to restrict?`,\r\n\t\t\t\t\t\tretry: message => `please mention a member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Restrict a members ability to post embeds/upload files.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: []\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('uh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst restrictRoles = this.client.settings.get(message.guild, 'restrictRoles', undefined);\r\n\t\tif (!restrictRoles) return message.reply('there are no restricted roles configured on this server.');\r\n\r\n\t\tconst key = `${message.guild.id}:${member.id}:EMBED`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\tawait member.roles.add(restrictRoles.embed, `Embed restricted by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error embed retricting this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Embed restriction', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.EMBED);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.EMBED,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully embed restricted **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = RestrictEmbedCommand;","path":"src/commands/mod/embed.js"},"reaction":{"name":"reaction-restrict","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass RestrictReactionCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('restrict-reaction', {\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: message => `what member do you want to restrict?`,\r\n\t\t\t\t\t\tretry: message => `please mention a member.`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tdefault: ''\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Restrict a members ability to use reactions.',\r\n\t\t\t\tusage: '<member> <...reason>',\r\n\t\t\t\texamples: []\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { member, reason }) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tif (member.id === message.author.id) return;\r\n\t\tif (member.roles.has(staffRole)) {\r\n\t\t\treturn message.reply('nuh-uh! You know you can\\'t do this.');\r\n\t\t}\r\n\r\n\t\tconst restrictRoles = this.client.settings.get(message.guild, 'restrictRoles', undefined);\r\n\t\tif (!restrictRoles) return message.reply('there are no restricted roles configured on this server.');\r\n\r\n\t\tconst key = `${message.guild.id}:${member.id}:REACTION`;\r\n\t\tif (this.client.cached.has(key)) {\r\n\t\t\treturn message.reply('that user is currently being moderated by someone else.');\r\n\t\t}\r\n\t\tthis.client.cached.add(key);\r\n\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0) + 1;\r\n\r\n\t\ttry {\r\n\t\t\tawait member.roles.add(restrictRoles.reaction, `Embed restricted by ${message.author.tag} | Case #${totalCases}`);\r\n\t\t} catch (error) {\r\n\t\t\tthis.client.cached.delete(key);\r\n\t\t\treturn message.reply(`there was an error muting this member: \\`${error}\\``);\r\n\t\t}\r\n\r\n\t\tthis.client.settings.set(message.guild, 'caseTotal', totalCases);\r\n\r\n\t\tif (!reason) {\r\n\t\t\tconst prefix = this.handler.prefix(message);\r\n\t\t\treason = `Use \\`${prefix}reason ${totalCases} <...reason>\\` to set a reason for this case`;\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tlet modMessage;\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst embed = Base.logEmbed({ message, member, action: 'Reaction restriction', caseNum: totalCases, reason }).setColor(Base.CONSTANTS.COLORS.REACTION);\r\n\t\t\tmodMessage = await (this.client.channels.get(modLogChannel)).send(embed);\r\n\t\t}\r\n\r\n\t\tawait Case.create({\r\n\t\t\tcaseID: totalCases,\r\n\t\t\ttargetID: member.id,\r\n\t\t\ttargetTag: member.user.tag,\r\n\t\t\tauthorTag: message.author.tag,\r\n\t\t\tauthorID: message.author.id,\r\n\t\t\tguildID: message.guild.id,\r\n\t\t\tmessageID: modMessage ? modMessage.id : undefined,\r\n\t\t\taction: Base.CONSTANTS.ACTIONS.REACTION,\r\n\t\t\treason: reason,\r\n\t\t\tcreatedAt: moment.utc().toDate()\r\n\t\t});\r\n\r\n\t\treturn message.util.send(`Successfully reaction restricted **${member.user.tag}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = RestrictReactionCommand;","path":"src/commands/mod/reaction.js"},"case":{"name":"case","type":"js","content":"const { Command, Argument } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\nconst ms = require('ms');\r\n\r\nconst ACTIONS = {\r\n\t1: 'Ban',\r\n\t2: 'Unban',\r\n\t3: 'Softban',\r\n\t4: 'Kick',\r\n\t5: 'Mute',\r\n\t6: 'Embed Restriction',\r\n\t7: 'Emoji Restriction',\r\n\t8: 'Reaction Restriction',\r\n\t9: 'Warn'\r\n};\r\n\r\nclass CaseCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('case', {\r\n\t\t\taliases: ['case'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES', 'EMBED_LINKS'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'caseNum',\r\n\t\t\t\t\ttype: Argument.union('number', 'string'),\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what case do you want to look up?`,\r\n\t\t\t\t\t\tretry: `please enter a case number.`\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Inspect a case, pulled from the database.',\r\n\t\t\t\tusage: '<case>',\r\n\t\t\t\texamples: ['1234']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { caseNum }) {\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0);\r\n\t\tconst caseToFind = caseNum === 'latest' || caseNum === 'l' ? totalCases : caseNum;\r\n\t\tif (isNaN(caseToFind)) return message.reply('at least provide me with a correct number.');\r\n\t\tconst db = await Case.findOne({ where: { caseID: caseToFind, guildID: message.guild.id }});\r\n\t\tif (!db) {\r\n\t\t\treturn message.reply('I couldn\\'t find a case with that Id!');\r\n\t\t}\r\n\r\n\t\tconst moderator = await message.guild.members.fetch(db.authorID);\r\n\t\tconst color = Object.keys(Base.CONSTANTS.ACTIONS).find(key => Base.CONSTANTS.ACTIONS[key] === db.action).split(' ')[0].toUpperCase();\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t\tif (db.authorID !== null) embed.setAuthor(`${db.authorTag} (${db.authorID})`, moderator ? moderator.user.displayAvatarURL() : '')\r\n\t\t\tembed.setColor(Base.CONSTANTS.COLORS[color])\r\n\t\t\tembed.setDescription([\r\n\t\t\t\t`**Member:** ${db.targetTag} (${db.targetID})`,\r\n\t\t\t\t`**Action:** ${ACTIONS[db.action]}${db.action === 5 ? `\\n**Length:** ${db.action_duration ? ms((db.action_duration - db.createdAt), { long: true }) : 'Not Set'}` : ''}`,\r\n\t\t\t\t`**Reason:** ${db.reason}${db.ref_id ? `\\n**Ref case:** ${db.ref_id}` : ''}`\r\n\t\t\t])\r\n\t\t\tembed.setFooter(`Case ${db.caseID}`)\r\n\t\t\tembed.setTimestamp(new Date(db.createdAt));\r\n\r\n\t\treturn message.util.send(embed);\r\n\t}\r\n}\r\n\r\nmodule.exports = CaseCommand;","path":"src/commands/mod/case.js"},"reason":{"name":"reason","type":"js","content":"const { Command, Argument } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst Case = require('../../models/Case');\r\nconst moment = require('moment');\r\n\r\nclass ReasonCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('reason', {\r\n\t\t\taliases: ['reason'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'caseNum',\r\n\t\t\t\t\ttype: Argument.union('number', 'string'),\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what case do you want to add a reason to?`,\r\n\t\t\t\t\t\tretry: `please enter a case number...`\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'reason',\r\n\t\t\t\t\tmatch: 'rest',\r\n\t\t\t\t\ttype: 'string'\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Sets/Updates the reason of a modlog entry.',\r\n\t\t\t\tusage: '<case> <...reason>',\r\n\t\t\t\texamples: ['1234 dumb', 'latest dumb']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tuserPermissions(message) {\r\n\t\tconst staffRole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst hasStaffRole = message.member.roles.has(staffRole);\r\n\t\tif (!hasStaffRole) return 'Moderator';\r\n\t\treturn null;\r\n\t}\r\n\r\n\tasync exec(message, { caseNum, reason }) {\r\n\t\tconst totalCases = this.client.settings.get(message.guild, 'caseTotal', 0);\r\n\t\tconst caseToFind = caseNum === 'latest' || caseNum === 'l' ? totalCases : caseNum;\r\n\t\tif (isNaN(caseToFind)) return message.reply('at least provide me with a correct number.');\r\n\r\n\t\tconst cases = await Case.findOne({ where: { caseID: caseToFind, guildID: message.guild.id }});\r\n\t\tif (!cases) {\r\n\t\t\treturn message.reply('I couldn\\'t find a case with that Id!');\r\n\t\t}\r\n\t\tif (cases.authorID && (cases.authorID !== message.author.id && !message.member.permissions.has('MANAGE_GUILD'))) {\r\n\t\t\treturn message.reply('you\\'d be wrong in thinking I would let you fiddle with other peoples achievements!');\r\n\t\t}\r\n\r\n\t\tconst modLogChannel = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tif (modLogChannel) {\r\n\t\t\tconst caseEmbed = await (this.client.channels.get(modLogChannel)).messages.fetch(cases.messageID);\r\n\t\t\tif (!caseEmbed) return message.reply('looks like the message doesn\\'t exist anymore!');\r\n\t\t\tconst embed = new MessageEmbed(caseEmbed.embeds[0]);\r\n\t\t\tembed.setAuthor(`${message.author.tag} (${message.author.id})`, message.author.displayAvatarURL())\r\n\t\t\t\t.setDescription(caseEmbed.embeds[0].description.replace(/\\*\\*Reason:\\*\\* [\\s\\S]+/, `**Reason:** ${reason}`));\r\n\t\t\tawait caseEmbed.edit(embed);\r\n\t\t}\r\n\r\n\t\tif (cases) {\r\n\t\t\tawait Case.update({\r\n\t\t\t\tauthorID: message.author.id,\r\n\t\t\t\tauthorTag: message.author.tag,\r\n\t\t\t\treason: reason,\r\n\t\t\t\tupdatedAt: moment.utc().toDate()\r\n\t\t\t}, { where : { caseID: caseToFind, guildID: message.guild.id }});\r\n\t\t}\r\n\r\n\t\treturn message.util.send(`Successfully set reason for case **#${caseToFind}**`);\r\n\t}\r\n}\r\n\r\nmodule.exports = ReasonCommand;","path":"src/commands/mod/reason.js"},"history":{"name":"history","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Base = require('../../util/Base');\r\nconst Case = require('../../models/Case');\r\n\r\nclass HistoryCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('history', {\r\n\t\t\taliases: ['history'],\r\n\t\t\tcategory: 'mod',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['MANAGE_ROLES', 'EMBED_LINKS'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tdefault: message => message.member\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Check the history of a member.',\r\n\t\t\t\tusage: '<member>',\r\n\t\t\t\texamples: ['@Suvajit']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { member }) {\r\n\t\tconst staffRole = message.member.roles.has(this.client.settings.get(message.guild, 'modRole', undefined));\r\n\t\tif (!staffRole && message.author.id !== member.id) return message.reply('you know, I know, we should just leave it at that.');\r\n\r\n\t\tconst cases = await Case.findAll({ where: { targetID: member.id, guildID: message.guild.id } });\r\n\t\tconst embed = Base.historyEmbed({member, cases});\r\n\r\n\t\treturn message.util.send(embed);\r\n\t}\r\n}\r\n\r\nmodule.exports = HistoryCommand;","path":"src/commands/mod/history.js"},"resethistory":{"name":"reset-history","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Case = require('../../models/Case');\r\n\r\nclass ResetHistoryCommand extends Command {\r\n    constructor() {\r\n        super('reset-history', {\r\n            aliases: ['reset-history'],\r\n            category: 'mod',\r\n            ownerOnly: true,\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'member',\r\n                    type: 'member'\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Deletes all cases for the specified user.',\r\n                usage: '<member>',\r\n                examples: ['@Suvajit']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { member }) {\r\n        if (!member) return;\r\n        const data = await Case.update({ action: 0 }, { where: { targetID: member.user.id, guildID: message.guild.id }});\r\n        if (data) {\r\n            return message.channel.send(`Successfully reset cases for **${member.user.tag}**`);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ResetHistoryCommand;","path":"src/commands/mod/resethistory.js"}}},"listeners":{"name":"Listeners","files":{"commandBlocked":{"name":"commandBlocked","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass CommandBlockedListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('commandBlocked', {\r\n\t\t\tevent: 'commandBlocked',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, reason) {\r\n\t\tconst text = {\r\n\t\t\towner: () => 'You must be the owner to use this command.',\r\n\t\t\tguild: () => 'You must be in a guild to use this command.'\r\n\t\t}[reason];\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${reason}`, { tag });\r\n\r\n\t\tif (!text) return;\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(text());\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = CommandBlockedListener;","path":"src/listeners/commandHandler/commandBlocked.js"},"commandStarted":{"name":"commandStarted","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\nconst Raven = require('raven');\r\nconst Levels = require('../../models/UserLevel');\r\nconst Commands = require('../../models/Commands');\r\n\r\nclass CommandStartedListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('commandStarted', {\r\n\t\t\tevent: 'commandStarted',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, command, args) {\r\n\t\tthis.client.prometheus.commandCounter.inc();\r\n\r\n\t\tif (message.guild && command.categoryID && command.categoryID !== 'owner') {\r\n\t\t\tconst _command = await Commands.findOne({ where: { guildID: message.guild.id, commandID: command.id }});\r\n\t\t\tif (_command) {\r\n\t\t\t\tawait Commands.update({\r\n\t\t\t\t\tuses: _command.uses + 1, categoryID: command.categoryID,\r\n\t\t\t\t\tcommandAlias: command.aliases ? command.aliases[0] : command.id\r\n\t\t\t\t}, { where: { guildID: message.guild.id, commandID: command.id }});\r\n\r\n\t\t\t} else await Commands.create({\r\n\t\t\t\tcommandID: command.id, guildID: message.guild.id, uses: 1, categoryID: command.categoryID,\r\n\t\t\t\tcommandAlias: command.aliases ? command.aliases[0] : command.id\r\n\t\t\t});\r\n\r\n\t\t\tif (command.id === 'tag-show') {\r\n\t\t\t\tconst _user = await Levels.findOne({ where: { guildID: message.guild.id, userID: message.author.id }});\r\n\t\t\t\tif (_user) {\r\n\t\t\t\t\tawait Levels.update({\r\n\t\t\t\t\t\ttagUses: _user.tagUses + 1\r\n\t\t\t\t\t}, { where: { guildID: message.guild.id, userID: message.author.id }});\r\n\r\n\t\t\t\t} else await Levels.create({ guildID: message.guild.id, userID: message.author.id, tagUses: 1 });\r\n\r\n\t\t\t} else if (command.categoryID !== 'tags') {\r\n\t\t\t\tconst _user = await Levels.findOne({ where: { guildID: message.guild.id, userID: message.author.id }});\r\n\t\t\t\tif (_user) {\r\n\t\t\t\t\tawait Levels.update({\r\n\t\t\t\t\t\tcommandUses: _user.commandUses + 1\r\n\t\t\t\t\t}, { where: { guildID: message.guild.id, userID: message.author.id }});\r\n\r\n\t\t\t\t} else await Levels.create({ guildID: message.guild.id, userID: message.author.id, commandUses: 1 });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} - ${message.author.tag}` : `${message.author.tag}`;\r\n\t\tLogger.log(`=> ${command.id}`, { tag });\r\n\r\n\t\tRaven.captureBreadcrumb({\r\n\t\t\tmessage: 'command_started',\r\n\t\t\tcategory: command.category.id,\r\n\t\t\tdata: {\r\n\t\t\t\tuser: {\r\n\t\t\t\t\tid: message.author.id,\r\n\t\t\t\t\tusername: message.author.tag\r\n\t\t\t\t},\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t},\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t},\r\n\t\t\t\targs\r\n\t\t\t}\r\n\t\t});\r\n\t\tRaven.setContext({\r\n\t\t\tuser: {\r\n\t\t\t\tid: message.author.id,\r\n\t\t\t\tusername: message.author.tag\r\n\t\t\t},\r\n\t\t\textra: {\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t},\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t},\r\n\t\t\t\targs\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = CommandStartedListener;","path":"src/listeners/commandHandler/commandStarted.js"},"cooldown":{"name":"cooldown","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass CooldownListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('cooldown', {\r\n\t\t\tevent: 'cooldown',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, remaining) {\r\n\t\tconst time = remaining / 1000;\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${time}`, { tag });\r\n\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(`You can use that command again in ${time} seconds.`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = CooldownListener;","path":"src/listeners/commandHandler/cooldown.js"},"error":{"name":"error","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\nconst Raven = require('raven');\r\n\r\nclass ErrorListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('error', {\r\n\t\t\tevent: 'error',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(error, message, command) {\r\n\r\n\t\tLogger.error('An error occured in a command.');\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.error(message.content, { tag });\r\n\t\tLogger.stacktrace(error);\r\n\r\n\t\tRaven.captureBreadcrumb({\r\n\t\t\tmessage: 'command_errored',\r\n\t\t\tcategory: command ? command.category.id : 'inhibitor',\r\n\t\t\tdata: {\r\n\t\t\t\tuser: {\r\n\t\t\t\t\tid: message.author.id,\r\n\t\t\t\t\tusername: message.author.tag\r\n\t\t\t\t},\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: command ? {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t} : null,\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tRaven.captureException(error);\r\n\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tconst owner = this.client.users.get(this.client.ownerID).tag;\r\n\t\t\tmessage.channel.send([\r\n\t\t\t\t'```js',\r\n\t\t\t\terror.toString(),\r\n\t\t\t\t'```'\r\n\t\t\t]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = ErrorListener;","path":"src/listeners/commandHandler/error.js"},"messageInvalid":{"name":"messageInvalid","type":"js","content":"const { Listener } = require('discord-akairo');\r\n\r\nclass MessageInvalidListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('messageInvalid', {\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tevent: 'messageInvalid',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tif (message.guild && message.util.parsed.prefix) {\r\n\t\t\tif (!message.util.parsed.alias || !message.util.parsed.afterPrefix) return;\r\n\t\t\tconst command = this.client.commandHandler.modules.get('tag-show');\r\n\t\t\t\r\n\t\t\treturn this.client.commandHandler.runCommand(message, command, await command.parse(message, message.util.parsed.afterPrefix));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = MessageInvalidListener;","path":"src/listeners/commandHandler/messageInvalid.js"},"missingPermissions":{"name":"missingPermissions","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass MissingPermissionsListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('missingPermissions', {\r\n\t\t\tevent: 'missingPermissions',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, type, missing) {\r\n\t\tconst text = {\r\n\t\t\tclient: () => {\r\n\t\t\t\tconst str = this.missingPermissions(message.channel, this.client.user, missing);\r\n\t\t\t\treturn `I'm missing ${str} to use that command.`;\r\n\t\t\t},\r\n\t\t\tuser: () => {\r\n\t\t\t\tconst str = this.missingPermissions(message.channel, message.author, missing);\r\n\t\t\t\treturn `You are missing ${str === undefined ? 'moderator permission' : str} to use that command.`;\r\n\t\t\t}\r\n\t\t}[type];\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${type}Permissions`, { tag });\r\n\r\n\t\tif (!text) return;\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(text());\r\n\t\t}\r\n\t}\r\n\r\n\tmissingPermissions(channel, user, permissions) {\r\n\t\tconst missingPerms = channel.permissionsFor(user).missing(permissions)\r\n\t\t\t.map(str => {\r\n\t\t\t\tif (str === 'VIEW_CHANNEL') return '`Read Messages`';\r\n\t\t\t\tif (str === 'SEND_TTS_MESSAGES') return '`Send TTS Messages`';\r\n\t\t\t\tif (str === 'USE_VAD') return '`Use VAD`';\r\n\t\t\t\treturn `\\`${str.replace(/_/g, ' ').toLowerCase().replace(/\\b(\\w)/g, char => char.toUpperCase())}\\``;\r\n\t\t\t});\r\n\r\n\t\treturn missingPerms.length > 1\r\n\t\t\t? `${missingPerms.slice(0, -1).join(', ')} and ${missingPerms.slice(-1)[0]}`\r\n\t\t\t: missingPerms[0];\r\n\t}\r\n}\r\n\r\nmodule.exports = MissingPermissionsListener;","path":"src/listeners/commandHandler/missingPermissions.js"}}},"inhibitors":{"name":"Inhibitors","files":{"blacklist":{"name":"blacklist","type":"js","content":"const { Inhibitor } = require('discord-akairo');\r\n\r\nclass BlacklistInhibitor extends Inhibitor {\r\n\tconstructor() {\r\n\t\tsuper('blacklist', {\r\n\t\t\treason: 'blacklist'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message) {\r\n\t\tconst blacklist = this.client.settings.get('global', 'blacklist', []);\r\n\t\treturn blacklist.includes(message.author.id);\r\n\t}\r\n}\r\n\r\nmodule.exports = BlacklistInhibitor;","path":"src/inhibitors/blacklist.js"},"moderation":{"name":"moderation","type":"js","content":"const { Inhibitor } = require('discord-akairo');\r\n\r\nclass ModerationInhibitor extends Inhibitor {\r\n\tconstructor() {\r\n\t\tsuper('moderation', {\r\n\t\t\treason: 'moderation'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message) {\r\n\t\tif (message.util.parsed && message.util.parsed.command && message.util.parsed.command.categoryID !== 'mod') return false;\r\n\t\tif (!this.client.settings.get(message.guild, 'moderation', undefined)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nmodule.exports = ModerationInhibitor;","path":"src/inhibitors/moderation.js"},"sendMessages":{"name":"sendMessages","type":"js","content":"const { Inhibitor } = require('discord-akairo');\r\n\r\nclass SendMessagesInhibitor extends Inhibitor {\r\n\tconstructor() {\r\n\t\tsuper('sendMessages', { reason: 'sendMessages' });\r\n\t}\r\n\r\n\texec(message, command) {\r\n\t\tif (!message.guild) return false;\r\n\t\tif (command.id === 'help') return false;\r\n\t\treturn !message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES');\r\n\t}\r\n}\r\n\r\nmodule.exports = SendMessagesInhibitor;","path":"src/inhibitors/sendMessages.js"}}},"struct":{"name":"struct","files":{"Database":{"name":"Database","type":"js","content":"const Logger = require('../util/Logger');\r\nconst path = require('path');\r\nconst readdir = require('util').promisify(require('fs').readdir);\r\nconst Sequelize = require('sequelize');\r\n\r\nconst db = new Sequelize(process.env.PostgreSQL, {\r\n\tlogging: false,\r\n\toperatorsAliases: Sequelize.Op\r\n});\r\n\r\nclass Database {\r\n\tstatic get db() {\r\n\t\treturn db;\r\n\t}\r\n\r\n\tstatic async authenticate() {\r\n\t\ttry {\r\n\t\t\tawait db.authenticate();\r\n\t\t\tLogger.info('Database connection has been established successfully...', { tag: 'PostgreSQL' });\r\n\t\t\tawait this.loadModels(path.join(__dirname, '..', 'models'));\r\n\t\t} catch (err) {\r\n\t\t\tLogger.error('Unable to connect to the Database...', { tag: 'PostgreSQL' });\r\n\t\t\tLogger.info('Attempting to connect again in 5 seconds...', { tag: 'PostgreSQL' });\r\n\t\t\tsetTimeout(this.authenticate, 5000);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic async loadModels(modelsPath) {\r\n\t\tconst files = await readdir(modelsPath);\r\n\t\tfor (const file of files) {\r\n\t\t\tconst filePath = path.join(modelsPath, file);\r\n\t\t\tif (!filePath.endsWith('.js')) continue;\r\n\t\t\tawait require(filePath).sync({ alter: true }); // eslint-disable-line no-await-in-loop\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = Database;\r\n","path":"src/struct/Database.js"},"MuteScheduler":{"name":"MuteScheduler","type":"js","content":"const { Op } = require('sequelize');\r\nconst Case = require('../models/Case');\r\nconst Logger = require('../util/Logger');\r\n\r\nclass MuteScheduler {\r\n\tconstructor(client, { checkRate =  5 * 60 * 1000 } = {}) {\r\n\t\tthis.client = client;\r\n\t\tthis.checkRate = checkRate;\r\n\t\tthis.checkInterval;\r\n\t\tthis.queuedSchedules = new Map();\r\n\t}\r\n\r\n\tasync addMute(mute, reschedule = false) {\r\n\t\tLogger.info(`Muted ${mute.targetTag} on ${this.client.guilds.get(`${mute.guildID}`).name}`, { tag: 'MUTE' });\r\n\t\tif (reschedule) Logger.info(`Rescheduled mute on ${mute.targetID} on ${this.client.guilds.get(mute.guildID)}`, { tag: 'Rescheduled Mute' });\r\n\t\tif (!reschedule) {\r\n\t\t\tawait Case.create({\r\n\t\t\t\tcaseID: mute.caseID,\r\n\t\t\t\ttargetID: mute.targetID,\r\n\t\t\t\ttargetTag: mute.targetTag,\r\n\t\t\t\tauthorID: mute.authorID,\r\n\t\t\t\tauthorTag: mute.authorTag,\r\n\t\t\t\tmessageID: mute.messageID,\r\n\t\t\t\tguildID: mute.guildID,\r\n\t\t\t\taction: mute.action,\r\n\t\t\t\taction_duration: mute.action_duration,\r\n\t\t\t\taction_processed: mute.action_processed,\r\n\t\t\t\treason: mute.reason\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (mute.action_duration < (Date.now() + this.checkRate)) {\r\n\t\t\tthis.queueMute(mute);\r\n\t\t}\r\n\t}\r\n\r\n\tasync cancelMute(mute) {\r\n\t\tLogger.info(`Unmuted ${mute.targetID} on ${this.client.guilds.get(mute.guildID)}`, { tag: 'UNMUTE' });\r\n\t\tconst guild = await this.client.guilds.get(`${mute.guildID}`);\r\n\t\tconst muteRole = await this.client.settings.get(guild, 'muteRole', undefined);\r\n\t\tlet member;\r\n\t\ttry {\r\n\t\t\tmember = await guild.members.fetch(mute.targetID);\r\n\t\t} catch {} // eslint:disable-line\r\n\t\tawait Case.update({\r\n\t\t\taction_processed : true\r\n\t\t}, { where: { guildID: guild.id, targetID: member.id }});\r\n\t\tif (member) {\r\n\t\t\ttry {\r\n\t\t\t\tawait member.roles.remove(muteRole, 'Unmuted automatically based on duration.');\r\n\t\t\t} catch {} // eslint:disable-line\r\n\t\t}\r\n\t\tconst schedule = this.queuedSchedules.get(mute);\r\n\t\tif (schedule) clearTimeout(schedule);\r\n\t\treturn this.queuedSchedules.delete(mute);\r\n\t}\r\n\r\n\tasync deleteMute(mute) {\r\n\t\tconst schedule = this.queuedSchedules.get(mute);\r\n\t\tif (schedule) clearTimeout(schedule);\r\n\t\tthis.queuedSchedules.delete(mute);\r\n\t\tconst deleted = await Case.destroy({ where: mute });\r\n\t\treturn deleted;\r\n\t}\r\n\r\n\tqueueMute(mute) {\r\n\t\tthis.queuedSchedules.set(mute, setTimeout(() => {\r\n\t\t\tthis.cancelMute(mute);\r\n\t\t}, mute.action_duration - Date.now()));\r\n\t}\r\n\r\n\trescheduleMute(mute) {\r\n\t\tLogger.info('Rescheduling Mute', { tag: 'Rescheduling Mute' });\r\n\t\tconst schedule = this.queuedSchedules.get(mute);\r\n\t\tif (schedule) clearTimeout(schedule);\r\n\t\tthis.queuedSchedules.delete(mute);\r\n\t\tthis.addMute(mute, true);\r\n\t}\r\n\r\n\tasync init() {\r\n\t\tawait this._check();\r\n\t\tthis.checkInterval = setInterval(this._check.bind(this), this.checkRate);\r\n\t}\r\n\r\n\tasync _check() {\r\n\t\tconst mutes = await Case.findAll({ where: { action_duration: { [Op.lt] : (new Date(Date.now() + this.checkRate)) }, action_processed: false, action: 5 }});\r\n\t\tconst now = new Date();\r\n\t\tfor (const mute of mutes) {\r\n\t\t\tif (this.queuedSchedules.has(mute)) continue;\r\n\t\t\tif (mute.action_duration < now) {\r\n\t\t\t\tthis.cancelMute(mute);\r\n\t\t\t} else {\r\n\t\t\t\tthis.queueMute(mute);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = MuteScheduler;","path":"src/struct/MuteScheduler.js"},"Queue":{"name":"Queue","type":"js","content":"const Logger = require('../util/Logger');\r\n\r\nclass Queue {\r\n\tconstructor() {\r\n\t\tthis._queue = [];\r\n\t\tthis._processing = false;\r\n\t}\r\n\r\n\tget length() {\r\n\t\treturn this._queue.length;\r\n\t}\r\n\r\n\tadd(promiseFunc) {\r\n\t\tthis._queue.push(promiseFunc);\r\n\t\tif (!this._processing) this._process();\r\n\t}\r\n\r\n\t_process() {\r\n\t\tthis._processing = true;\r\n\t\tconst promiseFunc = this._queue.shift();\r\n\r\n\t\tif (!promiseFunc) {\r\n\t\t\tthis._processing = false;\r\n\t\t} else {\r\n\t\t\tpromiseFunc().then(() => this._process()).catch(err => {\r\n\t\t\t\tLogger.error('An error occured in the queue');\r\n\t\t\t\tLogger.stacktrace(err);\r\n\t\t\t\treturn this._process();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = Queue;","path":"src/struct/Queue.js"},"SettingsProviders":{"name":"SettingsProviders","type":"js","content":"const { Guild } = require('discord.js');\r\nconst { SequelizeProvider } = require('discord-akairo');\r\n\r\nclass SettingsProvider extends SequelizeProvider {\r\n\tconstructor(table) {\r\n\t\tsuper(table, {\r\n\t\t\tidColumn: 'guildID',\r\n\t\t\tdataColumn: 'settings'\r\n\t\t});\r\n\t}\r\n\r\n\tget(guild, key, defaultValue) {\r\n\t\tconst id = this.constructor.getGuildID(guild);\r\n\t\treturn super.get(id, key, defaultValue);\r\n\t}\r\n\r\n\tset(guild, key, value) {\r\n\t\tconst id = this.constructor.getGuildID(guild);\r\n\t\treturn super.set(id, key, value);\r\n\t}\r\n\r\n\tdelete(guild, key) {\r\n\t\tconst id = this.constructor.getGuildID(guild);\r\n\t\treturn super.delete(id, key);\r\n\t}\r\n\r\n\tclear(guild) {\r\n\t\tconst id = this.constructor.getGuildID(guild);\r\n\t\treturn super.clear(id);\r\n\t}\r\n\r\n\tstatic getGuildID(guild) {\r\n\t\tif (guild instanceof Guild) return guild.id;\r\n\t\tif (guild === 'global' || guild === null) return 'global';\r\n\t\tif (typeof guild === 'string' && /^\\d+$/.test(guild)) return guild;\r\n\t\tthrow new TypeError('Invalid guild specified. Must be a Guild instance, guild ID, \"global\", or null.');\r\n\t}\r\n}\r\n\r\nmodule.exports = SettingsProvider;","path":"src/struct/SettingsProviders.js"},"Starboard":{"name":"Starboard","type":"js","content":"const { Collection } = require('discord.js');\r\nconst path = require('path');\r\nconst Star = require('../models/stars');\r\nconst Queue = require('./Queue');\r\nconst selfstarWarningTimeout = 60000;\r\n\r\nclass Starboard {\r\n\tconstructor(guild) {\r\n\t\tthis.client = guild.client;\r\n\t\tthis.guild = guild;\r\n\t\tthis.queues = new Collection();\r\n\t\tthis.reactionsRemoved = new Set();\r\n\t\tthis.recentlySelfstarred = new Set();\r\n\t}\r\n\r\n\tget channel() {\r\n\t\tconst channelID = this.client.settings.get(this.guild, 'starboardChannelID');\r\n\t\treturn this.guild.channels.get(channelID);\r\n\t}\r\n\r\n\tget threshold() {\r\n\t\treturn this.client.settings.get(this.guild, 'starThreshold', 1);\r\n\t}\r\n\r\n\tqueue(message, promiseFunc) {\r\n\t\tlet queue = this.queues.get(message.id);\r\n\t\tif (!queue) {\r\n\t\t\tthis.queues.set(message.id, new Queue());\r\n\t\t\tqueue = this.queues.get(message.id);\r\n\t\t}\r\n\r\n\t\treturn new Promise(resolve => {\r\n\t\t\tqueue.add(() => promiseFunc().then(res => {\r\n\t\t\t\tif (!queue.length) this.queues.delete(message.id);\r\n\t\t\t\tresolve(res);\r\n\t\t\t}));\r\n\t\t});\r\n\t}\r\n\r\n\tadd(message, starredBy) {\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\t\tif (blacklist.includes(starredBy.id)) {\r\n\t\t\treturn 'You have been blacklisted from using the starboard';\r\n\t\t}\r\n\r\n\t\tif (!this.channel) {\r\n\t\t\tconst prefix = this.client.commandHandler.prefix(message);\r\n\t\t\treturn `There isn't a starboard channel to use. Set one using the \\`${prefix}starboard\\` command!`;\r\n\t\t}\r\n\r\n\t\tconst missingPerms = this.missingPermissions();\r\n\t\tif (missingPerms) {\r\n\t\t\treturn missingPerms;\r\n\t\t}\r\n\r\n\t\tif (message.author.id === starredBy.id) {\r\n\t\t\tif (!this.recentlySelfstarred.has(message.author.id)) {\r\n\t\t\t\tthis.recentlySelfstarred.add(message.author.id);\r\n\t\t\t\tsetTimeout(() => this.recentlySelfstarred.delete(message.author.id), selfstarWarningTimeout);\r\n\t\t\t\treturn 'You can\\'t star your own messages.';\r\n\t\t\t}\r\n\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\treturn this.queue(message, () => this.addStar(message, starredBy));\r\n\t}\r\n\r\n\tasync addStar(message, starredBy) {\r\n\t\tconst star = await Star.findOne({ where: { messageID: message.id } });\r\n\r\n\t\tif (!star) {\r\n\t\t\tconst starboardMessage = this.threshold === 1\r\n\t\t\t\t? await this.channel.send({ embed: this.buildStarboardEmbed(message) })\r\n\t\t\t\t: null;\r\n\r\n\t\t\tawait Star.create({\r\n\t\t\t\tmessageID: message.id,\r\n\t\t\t\tauthorID: message.author.id,\r\n\t\t\t\tchannelID: message.channel.id,\r\n\t\t\t\tguildID: this.guild.id,\r\n\t\t\t\tstarboardMessageID: starboardMessage ? starboardMessage.id : null,\r\n\t\t\t\tstarredBy: [starredBy.id],\r\n\t\t\t\tstarCount: 1\r\n\t\t\t});\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tif (star.starredBy.includes(starredBy.id)) {\r\n\t\t\treturn 'You have already starred this message before; You can\\'t star it again.';\r\n\t\t}\r\n\r\n\t\tconst newStarredBy = star.starredBy.concat([starredBy.id]);\r\n\r\n\t\tlet starboardMessage;\r\n\t\tif (newStarredBy.length >= this.threshold) {\r\n\t\t\tconst embed = this.buildStarboardEmbed(message, newStarredBy.length);\r\n\t\t\tstarboardMessage = star.starboardMessageID\r\n\t\t\t\t? await this.channel.messages.fetch(star.starboardMessageID)\r\n\t\t\t\t\t.then(msg => msg.edit({ embed }))\r\n\t\t\t\t\t.catch(() => this.channel.send({ embed }))\r\n\t\t\t\t: await this.channel.send({ embed });\r\n\t\t}\r\n\r\n\t\tawait star.update({\r\n\t\t\tstarCount: newStarredBy.length,\r\n\t\t\tstarredBy: newStarredBy,\r\n\t\t\tstarboardMessageID: starboardMessage ? starboardMessage.id : null\r\n\t\t});\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tremove(message, unstarredBy) {\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\t\tif (blacklist.includes(unstarredBy.id)) return undefined;\r\n\t\tif (message.author.id === unstarredBy.id) return undefined;\r\n\r\n\t\tif (!this.channel) return undefined;\r\n\t\tif (this.missingPermissions()) return undefined;\r\n\r\n\t\treturn this.queue(message, () => this.removeStar(message, unstarredBy));\r\n\t}\r\n\r\n\tasync removeStar(message, unstarredBy) {\r\n\t\tconst star = await Star.findOne({ where: { messageID: message.id } });\r\n\t\tif (!star || !star.starredBy.includes(unstarredBy.id)) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tif (message.reactions.has('⭐')) {\r\n\t\t\tconst reaction = message.reactions.get('⭐');\r\n\t\t\tif (reaction.users.has(unstarredBy.id)) {\r\n\t\t\t\tawait reaction.users.remove(unstarredBy).then(() => {\r\n\t\t\t\t\tthis.reactionsRemoved.add(reaction.message.id);\r\n\t\t\t\t}).catch(() => null);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst newStarredBy = star.starredBy.filter(id => id !== unstarredBy.id);\r\n\r\n\t\tif (newStarredBy.length) {\r\n\t\t\tlet starboardMessage;\r\n\t\t\tif (newStarredBy.length >= this.threshold) {\r\n\t\t\t\tconst embed = this.buildStarboardEmbed(message, newStarredBy.length);\r\n\t\t\t\tstarboardMessage = star.starboardMessageID\r\n\t\t\t\t\t? await this.channel.messages.fetch(star.starboardMessageID)\r\n\t\t\t\t\t\t.then(msg => msg.edit({ embed }))\r\n\t\t\t\t\t\t.catch(() => this.channel.send({ embed }))\r\n\t\t\t\t\t: await this.channel.send({ embed });\r\n\t\t\t} else {\r\n\t\t\t\tconst msg = await this.channel.messages.fetch(star.starboardMessageID).catch(() => null);\r\n\t\t\t\tif (msg) await msg.delete();\r\n\t\t\t}\r\n\r\n\t\t\tawait star.update({\r\n\t\t\t\tstarCount: newStarredBy.length,\r\n\t\t\t\tstarredBy: newStarredBy,\r\n\t\t\t\tstarboardMessageID: starboardMessage ? starboardMessage.id : null\r\n\t\t\t});\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tif (star.starboardMessageID) {\r\n\t\t\tconst msg = await this.channel.messages.fetch(star.starboardMessageID).catch(() => null);\r\n\t\t\tif (msg) await msg.delete();\r\n\t\t}\r\n\r\n\t\tawait star.destroy();\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tdelete(message) {\r\n\t\tif (!this.channel) return undefined;\r\n\t\tif (this.missingPermissions()) return undefined;\r\n\t\treturn this.queue(message, () => this.deleteStar(message));\r\n\t}\r\n\r\n\tasync deleteStar(message) {\r\n\t\tconst star = await Star.findOne({ where: { messageID: message.id } });\r\n\t\tif (!star) return undefined;\r\n\r\n\t\tconst starboardMessage = star.starboardMessageID &&\r\n\t\t\tawait this.channel.messages.fetch(star.starboardMessageID).catch(() => null);\r\n\r\n\t\tif (starboardMessage) {\r\n\t\t\tawait starboardMessage.delete();\r\n\t\t}\r\n\r\n\t\tawait star.destroy();\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tfix(message) {\r\n\t\tconst missingPerms = this.missingPermissions();\r\n\t\tif (missingPerms) return missingPerms;\r\n\r\n\t\treturn this.queue(message, () => this.fixStar(message));\r\n\t}\r\n\r\n\tasync fixStar(message) {\r\n\t\tconst star = await Star.findOne({ where: { messageID: message.id } });\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\r\n\t\tconst fetchUsers = reaction => {\r\n\t\t\tconst users = this.client.util.collection();\r\n\t\t\tlet prevAmount = 0;\r\n\r\n\t\t\tconst fetch = async after => {\r\n\t\t\t\tconst fetched = await reaction.users.fetch({ after });\r\n\t\t\t\tif (fetched.size === prevAmount) return users;\r\n\r\n\t\t\t\tfor (const [k, v] of fetched) {\r\n\t\t\t\t\tusers.set(k, v);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprevAmount = fetched.size;\r\n\t\t\t\treturn fetch(fetched.last().id);\r\n\t\t\t};\r\n\r\n\t\t\treturn fetch();\r\n\t\t};\r\n\r\n\t\tif (!star) {\r\n\t\t\tif (!message.reactions.has('⭐')) return undefined;\r\n\r\n\t\t\tconst users = await fetchUsers(message.reactions.get('⭐'));\r\n\t\t\tconst starredBy = users\r\n\t\t\t\t.map(user => user.id)\r\n\t\t\t\t.filter(user => message.author.id !== user && !blacklist.includes(user));\r\n\r\n\t\t\tif (!starredBy.length) return undefined;\r\n\r\n\t\t\tlet starboardMessage;\r\n\t\t\tif (starredBy.length >= this.threshold) {\r\n\t\t\t\tconst embed = this.buildStarboardEmbed(message, starredBy.length);\r\n\t\t\t\tstarboardMessage = await this.channel.send({ embed });\r\n\t\t\t} else if (star.starboardMessageID) {\r\n\t\t\t\tconst msg = await this.channel.messages.fetch(star.starboardMessageID).catch(() => null);\r\n\t\t\t\tif (msg) await msg.delete();\r\n\t\t\t}\r\n\r\n\t\t\tawait Star.create({\r\n\t\t\t\tstarredBy,\r\n\t\t\t\tmessageID: message.id,\r\n\t\t\t\tauthorID: message.author.id,\r\n\t\t\t\tchannelID: message.channel.id,\r\n\t\t\t\tguildID: this.guild.id,\r\n\t\t\t\tstarboardMessageID: starboardMessage ? starboardMessage.id : null,\r\n\t\t\t\tstarCount: starredBy.length\r\n\t\t\t});\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tconst users = message.reactions.has('⭐')\r\n\t\t\t? await fetchUsers(message.reactions.get('⭐'))\r\n\t\t\t: this.client.util.collection();\r\n\r\n\t\tconst newStarredBy = users\r\n\t\t\t.map(user => user.id)\r\n\t\t\t.filter(user => !star.starredBy.includes(user) && message.author.id !== user && !blacklist.includes(user))\r\n\t\t\t.concat(star.starredBy);\r\n\r\n\t\tlet starboardMessage;\r\n\t\tif (newStarredBy.length >= this.threshold) {\r\n\t\t\tconst embed = this.buildStarboardEmbed(message, newStarredBy.length);\r\n\t\t\tstarboardMessage = star.starboardMessageID\r\n\t\t\t\t? await this.channel.messages.fetch(star.starboardMessageID)\r\n\t\t\t\t\t.then(msg => msg.edit({ embed }))\r\n\t\t\t\t\t.catch(() => this.channel.send({ embed }))\r\n\t\t\t\t: await this.channel.send({ embed });\r\n\t\t} else {\r\n\t\t\tconst msg = await this.channel.messages.fetch(star.starboardMessageID).catch(() => null);\r\n\t\t\tif (msg) await msg.delete();\r\n\t\t}\r\n\r\n\t\tawait star.update({\r\n\t\t\tstarCount: newStarredBy.length,\r\n\t\t\tstarredBy: newStarredBy,\r\n\t\t\tstarboardMessageID: starboardMessage ? starboardMessage.id : null\r\n\t\t});\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\treturn Star.destroy({ where: { guildID: this.guild.id } });\r\n\t}\r\n\r\n\tmissingPermissions() {\r\n\t\tconst { missingPermissions } = this.client.listenerHandler.modules.get('missingPermissions');\r\n\t\tconst str = missingPermissions(this.channel, this.client.user, [\r\n\t\t\t'VIEW_CHANNEL',\r\n\t\t\t'MANAGE_MESSAGES',\r\n\t\t\t'READ_MESSAGE_HISTORY',\r\n\t\t\t'SEND_MESSAGES',\r\n\t\t\t'EMBED_LINKS'\r\n\t\t]);\r\n\r\n\t\tif (!str) return undefined;\r\n\t\treturn `I'm missing ${str} to do that!`;\r\n\t}\r\n\r\n\tbuildStarboardEmbed(message, starCount = 1) {\r\n\t\tconst star = Starboard.getStarEmoji(starCount);\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0xFFAC33)\r\n\t\t\t.addField('Author', message.author, true)\r\n\t\t\t.addField('Channel', message.channel, true)\r\n\t\t\t.setThumbnail(message.author.displayAvatarURL())\r\n\t\t\t.setTimestamp(message.createdAt)\r\n\t\t\t.setFooter(`${star} ${starCount} | ${message.id}`);\r\n\r\n\t\tif (message.content) {\r\n\t\t\tlet content = message.content.substring(0, 1000);\r\n\t\t\tif (message.content.length > 1000) content += '...';\r\n\t\t\tembed.addField('Message', content);\r\n\t\t}\r\n\r\n\t\tembed.addField('Message', `[Jump To](${message.url})`);\r\n\r\n\t\tconst attachment = Starboard.findAttachment(message);\r\n\t\tif (attachment) {\r\n\t\t\tembed.setImage(attachment);\r\n\t\t}\r\n\r\n\t\treturn embed;\r\n\t}\r\n\r\n\tstatic findAttachment(message) {\r\n\t\tlet attachmentImage;\r\n\t\tconst extensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp'];\r\n\t\tconst linkRegex = /https?:\\/\\/(?:\\w+\\.)?[\\w-]+\\.[\\w]{2,3}(?:\\/[\\w-_.]+)+\\.(?:png|jpg|jpeg|gif|webp)/;\r\n\r\n\t\tconst richEmbed = message.embeds.find(embed => embed.type === 'rich' &&\r\n\t\t\tembed.image &&\r\n\t\t\textensions.includes(path.extname(embed.image.url)));\r\n\t\tif (richEmbed) {\r\n\t\t\tattachmentImage = richEmbed.image.url;\r\n\t\t}\r\n\r\n\t\tconst attachment = message.attachments.find(file => extensions.includes(path.extname(file.url)));\r\n\t\tif (attachment) {\r\n\t\t\tattachmentImage = attachment.url;\r\n\t\t}\r\n\r\n\t\tif (!attachmentImage) {\r\n\t\t\tconst linkMatch = message.content.match(linkRegex);\r\n\t\t\tif (linkMatch && extensions.includes(path.extname(linkMatch[0]))) {\r\n\t\t\t\tattachmentImage = linkMatch[0];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn attachmentImage;\r\n\t}\r\n\r\n\tstatic getStarEmoji(count) {\r\n\t\tif (count < 5) return '⭐';\r\n\t\tif (count < 10) return '🌟';\r\n\t\tif (count < 15) return '✨';\r\n\t\tif (count < 20) return '💫';\r\n\t\tif (count < 30) return '🎇';\r\n\t\tif (count < 40) return '🎆';\r\n\t\tif (count < 50) return '☄️';\r\n\t\tif (count < 75) return '🌠';\r\n\t\tif (count < 100) return '🌌';\r\n\t\tif (count < 150) return '🌌•⭐';\r\n\t\tif (count < 200) return '🌌•🌟';\r\n\t\tif (count < 300) return '🌌•✨';\r\n\t\tif (count < 400) return '🌌•💫';\r\n\t\tif (count < 650) return '🌌•🎇';\r\n\t\tif (count < 900) return '🌌•🎆';\r\n\t\tif (count < 1400) return '🌌•☄️';\r\n\t\tif (count < 2400) return '🌌•🌠';\r\n\t\treturn '🌌•🌌';\r\n\t}\r\n\r\n\tstatic getEscapedStarEmoji(count) {\r\n\t\tconst emoji = this.getStarEmoji(count);\r\n\t\treturn `\\\\${emoji.replace('•', '•\\\\')}`;\r\n\t}\r\n}\r\n\r\nmodule.exports = Starboard;","path":"src/struct/Starboard.js"}}},"models":{"name":"models","files":{"Case":{"name":"Case","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Case = db.define('cases', {\r\n    caseID: {\r\n        type: Sequelize.INTEGER,\r\n        allowNull: false\r\n    },\r\n    targetID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    targetTag: {\r\n        type: Sequelize.TEXT,\r\n        allowNull: true\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    authorID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: true\r\n    },\r\n    authorTag:{\r\n        type: Sequelize.TEXT,\r\n        allowNull: true\r\n    },\r\n    messageID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: true,\r\n    },\r\n    reason: {\r\n        type: Sequelize.TEXT,\r\n        allowNull: true\r\n    },\r\n    action: {\r\n        type: Sequelize.INTEGER,\r\n        allowNull: true\r\n    },\r\n    action_duration: {\r\n        type: Sequelize.DATE(6),\r\n        allowNull: true\r\n    },\r\n    action_processed: {\r\n        type: Sequelize.BOOLEAN,\r\n        allowNull: true\r\n    },\r\n    createdAt: {\r\n        allowNull: false,\r\n        type: Sequelize.DATE,\r\n        defaultValue: Sequelize.NOW\r\n    },\r\n    updatedAt: {\r\n        allowNull: false,\r\n        type: Sequelize.DATE,\r\n        defaultValue: Sequelize.NOW\r\n    }\r\n});\r\n\r\nmodule.exports = Case;","path":"src/models/Case.js"},"Commands":{"name":"Commands","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Commands = db.define('commands', {\r\n    commandID: {\r\n        type: Sequelize.TEXT,\r\n        allowNull: false\r\n    },\r\n    categoryID: {\r\n        type: Sequelize.STRING,\r\n        defaultValue: ''\r\n    },\r\n    commandAlias: {\r\n        type: Sequelize.STRING,\r\n        defaultValue: ''\r\n    },\r\n    uses: {\r\n        type: Sequelize.INTEGER,\r\n        defaultValue: 0\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    }\r\n})\r\n\r\nmodule.exports = Commands;","path":"src/models/Commands.js"},"ReactionRoles":{"name":"ReactionRoles","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst ReactionRole = db.define('reactionroles', {\r\n    messageID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    roleID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    channelID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    emoji: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    }\r\n})\r\n\r\nmodule.exports = ReactionRole;","path":"src/models/ReactionRoles.js"},"reputations":{"name":"Reputations","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Reputation = db.define('reputations', {\r\n\tsourceID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\ttargetID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\tguildID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\treason: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tdefaultValue: ''\r\n\t}\r\n});\r\n\r\nmodule.exports = Reputation;\r\n","path":"src/models/reputations.js"},"stars":{"name":"Stars","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Star = db.define('stars', {\r\n\tmessageID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tprimaryKey: true,\r\n\t\tallowNull: false\r\n\t},\r\n\tauthorID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\tchannelID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\tguildID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: false\r\n\t},\r\n\tstarboardMessageID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tallowNull: true\r\n\t},\r\n\tstarCount: {\r\n\t\ttype: Sequelize.INTEGER,\r\n\t\tallowNull: false,\r\n\t\tdefaultValue: 1\r\n\t},\r\n\tstarredBy: {\r\n\t\ttype: Sequelize.ARRAY(Sequelize.STRING), // eslint-disable-line new-cap\r\n\t\tallowNull: false\r\n\t}\r\n});\r\n\r\nmodule.exports = Star;\r\n","path":"src/models/stars.js"},"Rolestate":{"name":"Rolestate","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Rolestate = db.define('roles', {\r\n    userID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    rolesID: {\r\n        type: Sequelize.ARRAY(Sequelize.STRING),\r\n        allowNull: true\r\n    }\r\n});\r\n\r\nmodule.exports = Rolestate;","path":"src/models/Rolestate.js"},"settings":{"name":"Settings","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Setting = db.define('settings', {\r\n\tguildID: {\r\n\t\ttype: Sequelize.STRING,\r\n\t\tprimaryKey: true,\r\n\t\tallowNull: false\r\n\t},\r\n\tsettings: {\r\n\t\t'type': Sequelize.JSONB,\r\n\t\t'allowNull': false,\r\n\t\t'default': {}\r\n\t}\r\n});\r\n\r\nmodule.exports = Setting;\r\n","path":"src/models/settings.js"},"Tags":{"name":"Tags","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Tags = db.define('tags', {\r\n    authorID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    name: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    aliases: {\r\n        type: Sequelize.ARRAY(Sequelize.TEXT), // eslint-disable-line new-cap\r\n        allowNull: true\r\n    },\r\n    hoisted: {\r\n        allowNull: false,\r\n\t\ttype: Sequelize.BOOLEAN,\r\n        defaultValue: false\r\n    },\r\n    content: {\r\n        type: Sequelize.TEXT,\r\n        allowNull: false\r\n    },\r\n    uses: {\r\n        type: Sequelize.INTEGER,\r\n        allowNull: true,\r\n        defaultValue: 0\r\n    },\r\n    last_modified: {\r\n        allowNull: true,\r\n        type: Sequelize.STRING,\r\n    },\r\n    createdAt: {\r\n        allowNull: false,\r\n        type: Sequelize.DATE,\r\n        defaultValue: Sequelize.NOW\r\n    },\r\n    updatedAt: {\r\n        allowNull: false,\r\n        type: Sequelize.DATE,\r\n        defaultValue: Sequelize.NOW\r\n    }\r\n});\r\n\r\nmodule.exports = Tags;","path":"src/models/Tags.js"},"UserLevel":{"name":"UserLevel","type":"js","content":"const { db } = require('../struct/Database');\r\nconst Sequelize = require('sequelize');\r\n\r\nconst Levels = db.define('userlevels', {\r\n    userID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    commandUses: {\r\n        type: Sequelize.INTEGER,\r\n        defaultValue: 0\r\n    },\r\n    tagUses: {\r\n        type: Sequelize.INTEGER,\r\n        defaultValue: 0\r\n    },\r\n    guildID: {\r\n        type: Sequelize.STRING,\r\n        allowNull: false\r\n    },\r\n    level: {\r\n        type: Sequelize.INTEGER,\r\n        defaultValue: 0\r\n    }\r\n})\r\n\r\nmodule.exports = Levels;","path":"src/models/UserLevel.js"}}},"util":{"name":"util","files":{"Base":{"name":"Base","type":"js","content":"const { MessageEmbed, User } = require('discord.js');\r\nconst { oneLine } = require('common-tags');\r\nconst ms = require('ms');\r\n\r\nconst ACTIONS = ({\r\n\t1: 'ban',\r\n\t2: 'unban',\r\n\t3: 'kick',\r\n\t4: 'kick',\r\n\t5: 'mute',\r\n\t6: 'restriction',\r\n\t7: 'restriction',\r\n\t8: 'restriction',\r\n\t9: 'warn'\r\n});\r\n\r\nconst Base = {\r\n    CONSTANTS : {\r\n        ACTIONS: {\r\n\t\t\tBAN: 1,\r\n\t\t\tUNBAN: 2,\r\n\t\t\tSOFTBAN: 3,\r\n\t\t\tKICK: 4,\r\n\t\t\tMUTE: 5,\r\n\t\t\tEMBED: 6,\r\n\t\t\tEMOJI: 7,\r\n\t\t\tREACTION: 8,\r\n\t\t\tWARN: 9\r\n\t\t},\r\n        COLORS : {\r\n            BAN: 16718080,\r\n            UNBAN: 8450847,\r\n            SOFTBAN: 16745216,\r\n            KICK: 16745216,\r\n            MUTE: 16763904,\r\n            EMBED: 16776960,\r\n            EMOJI: 16776960,\r\n            REACTION: 16776960,\r\n            WARN: 16776960\r\n        }\r\n    },\r\n\r\n    logEmbed : ({message, member, duration, caseNum, action, reason}) => {\r\n        const embed = new MessageEmbed().setTimestamp().setFooter(`Case ${caseNum}`)\r\n        if (message) embed.setAuthor(`${message.member.user.tag} (${message.member.user.id})`, message.member.user.displayAvatarURL())\r\n        embed.setDescription([`**Member:** ${member instanceof User ? member.tag : member.user.tag} (${member.id})`,\r\n        `**Action:** ${action}${action === 'Mute' && duration ? `\\n**Length:** ${ms(duration, { long: true })}` : ''}`,\r\n        `**Reason:** ${reason}`]);\r\n        return embed;\r\n    },\r\n\r\n    historyEmbed : ({ message, member, cases }) => {\r\n        const footer = cases.reduce((count, c) => {\r\n\t\t\tconst action = ACTIONS[c.action];\r\n\t\t\tcount[action] = (count[action] || 0) + 1;\r\n\t\t\treturn count;\r\n\t\t}, {});\r\n\t\tconst colors = [8450847, 10870283, 13091073, 14917123, 16152591, 16667430, 16462404];\r\n\t\tconst values = [footer.warn || 0, footer.restriction || 0, footer.mute || 0, footer.kick || 0, footer.ban || 0];\r\n\t\tconst [warn, restriction, mute, kick, ban] = values;\r\n\t\tconst colorIndex = Math.min(values.reduce((a, b) => a + b), colors.length - 1);\r\n        return new MessageEmbed().setColor(colors[colorIndex])\r\n        .setAuthor(`${member.user.tag} (${member.user.id})`, member.user.displayAvatarURL())\r\n        .setFooter(oneLine`${warn} warning${warn > 1 || warn === 0 ? 's' : ''},\r\n        ${restriction} restriction${restriction > 1 || restriction === 0 ? 's' : ''},\r\n        ${mute} mute${mute > 1 || mute === 0 ? 's' : ''},\r\n        ${kick} kick${kick > 1 || kick === 0 ? 's' : ''},\r\n        and ${ban} ban${ban > 1 || ban === 0 ? 's' : ''}`);\r\n    },\r\n\r\n    paginate : ({ items, page = 1, pageLength = 10 }) => {\r\n        const maxPage = Math.ceil(items.length / pageLength);\r\n        if (page < 1) page = 1;\r\n        if (page > maxPage) page = maxPage;\r\n        const startIndex = (page - 1) * pageLength;\r\n        return {\r\n            items: items.length > pageLength ? items.slice(startIndex, startIndex + pageLength) : items,\r\n            page,\r\n            maxPage,\r\n            pageLength\r\n        };\r\n    },\r\n    \r\n    timeString : ({seconds, forceHours = false, ms = true}) => {\r\n        if (ms) seconds /= 1000;\r\n        const hours = Math.floor(seconds / 3600);\r\n        const minutes = Math.floor(seconds % 3600 / 60);\r\n        return `${forceHours || hours >= 1 ? `${hours}:` : ''}${hours >= 1 ? `0${minutes}`.slice(-2) : minutes}:${`0${Math.floor(seconds % 60)}`.slice(-2)}`;\r\n    }\r\n}\r\n\r\nmodule.exports = Base;","path":"src/util/Base.js"},"Extensions":{"name":"Extensions","type":"js","content":"const { CommandUtil } = require('discord-akairo');\r\nconst { Message } = require('discord.js');\r\n\r\n/* eslint-disable func-name-matching */\r\n\r\nObject.defineProperty(CommandUtil.prototype, 'reply', {\r\n\tvalue: function reply(content, options) {\r\n\t\treturn this.send(`${this.message.author} **::** ${Array.isArray(content) ? content.join('\\n') : content}`, options);\r\n\t}\r\n});\r\n\r\nObject.defineProperty(Message.prototype, 'reply', {\r\n\tvalue: function reply(content, options) {\r\n\t\treturn this.channel.send(`${this.author} **::** ${Array.isArray(content) ? content.join('\\n') : content}`, options);\r\n\t}\r\n});","path":"src/util/Extensions.js"},"Logger":{"name":"Logger","type":"js","content":"const chalk = require('chalk');\r\nconst moment = require('moment');\r\nconst util = require('util');\r\n\r\nclass Logger {\r\n\tstatic log(content, { color = 'grey', tag = 'Log' } = {}) {\r\n\t\tthis.write(content, { color, tag });\r\n\t}\r\n\r\n\tstatic info(content, { color = 'green', tag = 'Info' } = {}) {\r\n\t\tthis.write(content, { color, tag });\r\n\t}\r\n\r\n\tstatic warn(content, { color = 'yellow', tag = 'Warn' } = {}) {\r\n\t\tthis.write(content, { color, tag });\r\n\t}\r\n\r\n\tstatic error(content, { color = 'red', tag = 'Error' } = {}) {\r\n\t\tthis.write(content, { color, tag, error: true });\r\n\t}\r\n\r\n\tstatic stacktrace(content, { color = 'white', tag = 'Error' } = {}) {\r\n\t\tthis.write(content, { color, tag, error: true });\r\n\t}\r\n\r\n\tstatic write(content, { color = 'grey', tag = 'Log', error = false } = {}) {\r\n\t\tconst timestamp = chalk.cyan(`[${moment().format('DD-MM-YYYY HH:mm:ss')}]:`);\r\n\t\tconst levelTag = chalk.bold(`[${tag}]:`);\r\n\t\tconst text = chalk[color](this.clean(content));\r\n\t\tconst stream = error ? process.stderr : process.stdout;\r\n\t\tstream.write(`${timestamp} ${levelTag} ${text}\\n`);\r\n\t}\r\n\r\n\tstatic clean(item) {\r\n\t\tif (typeof item === 'string') return item;\r\n\t\tconst cleaned = util.inspect(item, { depth: Infinity });\r\n\t\treturn cleaned;\r\n\t}\r\n}\r\n\r\nmodule.exports = Logger;","path":"src/util/Logger.js"},"Winston":{"name":"Winston","type":"js","content":"const { createLogger, transports, format } = require('winston');\r\nconst DailyRotateFile = require('winston-daily-rotate-file');\r\n\r\nconst Logger = createLogger({\r\n    format: format.combine(\r\n        format.colorize({ level: true }),\r\n        format.timestamp({ format: 'DD-MM-YYYY HH:mm:ss' }),\r\n        format.printf(info => {\r\n            const { timestamp, level, message, ...rest } = info;\r\n            return `[${timestamp}] ${level}: ${message}${Object.keys(rest).length ? `\\n${JSON.stringify(rest, null, 2)}` : ''}`;\r\n        })\r\n    ),\r\n    transports: [\r\n        new transports.Console({ level: 'info' }),\r\n        new DailyRotateFile({\r\n            format: format.combine(\r\n                format.timestamp(),\r\n                format.json()\r\n            ),\r\n            level: 'debug',\r\n            filename: './logger/%DATE%.log',\r\n            maxFiles: '14d'\r\n        })\r\n    ]\r\n});\r\n\r\nmodule.exports = Logger;","path":"src/util/Winston.js"}}}},"classes":[],"interfaces":[],"typedefs":[],"externals":[]}