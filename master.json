{
  "meta": {
    "generator": "0.2.0",
    "format": 19,
    "date": 1555002813425
  },
  "custom": {
    "client": {
      "name": "client",
      "files": {
        "Client": {
          "name": "Client",
          "type": "js",
          "content": "const { AkairoClient, CommandHandler, InhibitorHandler, ListenerHandler } = require('discord-akairo');\r\nconst { Counter, collectDefaultMetrics, register } = require('prom-client');\r\nconst SettingsProvider = require('../struct/SettingsProviders');\r\nconst MuteScheduler = require('../struct/MuteScheduler');\r\nconst ReactionRole = require('../models/ReactionRoles');\r\nconst { Client: Lavaqueue } = require('lavaqueue');\r\nconst { Collection, Util } = require('discord.js');\r\nconst Database = require('../struct/Database');\r\nconst Playlist = require('../models/Playlist');\r\nconst Setting = require('../models/settings');\r\nconst { createServer } = require('http');\r\nconst Case = require('../models/Case');\r\nconst { Rejects } = require('rejects');\r\nconst Tags = require('../models/Tags');\r\nconst { Op } = require('sequelize');\r\nconst { parse } = require('url');\r\nconst path = require('path');\r\n\r\nclass Client extends AkairoClient {\r\n\tconstructor(config) {\r\n\t\tsuper({ ownerID: config.owner }, {\r\n\t\t\tmessageCacheMaxSize: 50,\r\n\t\t\tmessageCacheLifetime: 300,\r\n\t\t\tmessageSweepInterval: 900,\r\n\t\t\tdisableEveryone: true,\r\n\t\t\tdisabledEvents: ['TYPING_START']\r\n\t\t});\r\n\r\n\t\tthis.commandHandler = new CommandHandler(this, {\r\n\t\t\tdirectory: path.join(__dirname, '..', 'commands'),\r\n\t\t\taliasReplacement: /-/g,\r\n\t\t\tprefix: message => this.settings.get(message.guild, 'prefix', '*'),\r\n\t\t\tallowMention: true,\r\n\t\t\tfetchMembers: true,\r\n\t\t\tcommandUtil: true,\r\n\t\t\tcommandUtilLifetime: 3e5,\r\n\t\t\tcommandUtilSweepInterval: 9e5,\r\n\t\t\thandleEdits: true,\r\n\t\t\tdefaultCooldown: 3000,\r\n\t\t\tdefaultPrompt: {\r\n\t\t\t\tmodifyStart: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\tmodifyRetry: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\ttimeout: msg => `${msg.author} **::** Time ran out, command has been cancelled.`,\r\n\t\t\t\tended: msg => `${msg.author} **::** Too many retries, command has been cancelled.`,\r\n\t\t\t\tcancel: msg => `${msg.author} **::** Command has been cancelled.`,\r\n\t\t\t\tretries: 2,\r\n\t\t\t\ttime: 30000\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.inhibitorHandler = new InhibitorHandler(this, { directory: path.join(__dirname, '..', 'inhibitors') });\r\n\t\tthis.listenerHandler = new ListenerHandler(this, { directory: path.join(__dirname, '..', 'listeners') });\r\n\r\n\t\tthis.prometheus = {\r\n            messagesCounter: new Counter({ name: 'raven_messages_total', help: 'Total number of messages have seen' }),\r\n            commandCounter: new Counter({ name: 'raven_commands_total', help: 'Total number of commands used' }),\r\n            collectDefaultMetrics,\r\n            register\r\n        };\r\n        this.prometheus.collectDefaultMetrics({ prefix: 'raven_', timeout: 30000 });\r\n\r\n\t\tthis.music = new Lavaqueue({\r\n\t\t\tuserID: process.env.ID,\r\n\t\t\tpassword: process.env.PASS,\r\n\t\t\thosts: {\r\n\t\t\t\trest: process.env.REST,\r\n\t\t\t\tws: process.env.WS,\r\n\t\t\t\tredis: {\r\n\t\t\t\t\tport: process.env.PORT,\r\n\t\t\t\t\thost: process.env.HOST,\r\n\t\t\t\t\tdb: process.env.DB\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsend: async (guild, packet) => {\r\n\t\t\t\tconst shardGuild = this.guilds.get(guild);\r\n\t\t\t\tif (shardGuild) return shardGuild.shard.send(packet);\r\n\t\t\t\treturn Promise.resolve();\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tthis.config = config;\r\n\t\tthis.storage = new Rejects(this.music.queues.redis);\r\n\t\tthis.settings = new SettingsProvider(Setting);\r\n\t\tthis.muteScheduler = new MuteScheduler(this, Case);\r\n\t\tthis.starboards = new Collection();\r\n\t\tthis.cached = new Set();\r\n\r\n\t\tthis.commandHandler.resolver.addType('tag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn tag || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('existingTag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { guildID: message.guild.id,\r\n\t\t\t\t[Op.or]: [\r\n\t\t\t\t\t{ name: phrase },\r\n\t\t\t\t\t{ aliases: { [Op.contains]: [phrase] } }\r\n\t\t\t\t]\r\n\t\t\t}});\r\n\r\n\t\t\treturn tag ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('tagContent', (phrase, message) => {\r\n\t\t\tif (!phrase) phrase = '';\r\n\t\t\tphrase = Util.cleanContent(phrase, message);\r\n\t\t\tif (message.attachments.first()) phrase += `\\n${message.attachments.first().url}`;\r\n\r\n\t\t\treturn phrase || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('reactionRole', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tconst msg = await ReactionRole.findOne({ where: { guildID: message.guild.id, messageID: phrase }});\r\n\t\t\treturn msg || null;\r\n\t\t})\r\n\r\n\t\tthis.commandHandler.resolver.addType('playlist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist || null;\r\n\t\t});\r\n\t\t\r\n\t\tthis.commandHandler.resolver.addType('existingPlaylist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.setup();\r\n\r\n\t\t/*\r\n\t\tsetInterval(() => {\r\n\t\t\tfor (const guild of this.guilds.values()) {\r\n\t\t\t\tguild.presences.clear();\r\n\t\t\t}\r\n\t\t}, 900);\r\n\t\t*/\r\n\t}\r\n\r\n\tasync setup() {\r\n\t\tthis.commandHandler.useInhibitorHandler(this.inhibitorHandler);\r\n\t\tthis.commandHandler.useListenerHandler(this.listenerHandler);\r\n\t\tthis.listenerHandler.setEmitters({\r\n\t\t\tcommandHandler: this.commandHandler,\r\n\t\t\tinhibitorHandler: this.inhibitorHandler,\r\n\t\t\tlistenerHandler: this.listenerHandler\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.loadAll();\r\n\t\tthis.inhibitorHandler.loadAll();\r\n\t\tthis.listenerHandler.loadAll();\r\n\t}\r\n\r\n\tasync metrics() {\r\n\t\tcreateServer((req, res) => {\r\n\t\t\tif (parse(req.url).pathname === '/metrics') {\r\n\t\t\t\tres.writeHead(200, { 'Content-Type': this.prometheus.register.contentType });\r\n\t\t\t\tres.write(this.prometheus.register.metrics());\r\n\t\t\t};\r\n\t\t\tres.end();\r\n\t\t}).listen(8080);\r\n    };\r\n\r\n\tasync start() {\r\n\t\tawait Database.authenticate();\r\n\t\tawait this.settings.init();\r\n\t\treturn this.login(this.config.token);\r\n\t}\r\n}\r\n\r\nmodule.exports = Client;\r\n",
          "path": "src/client/Client.js"
        }
      }
    },
    "commands": {
      "name": "commands",
      "files": {
        "docs": {
          "name": "Docs",
          "type": "js",
          "content": "const { Command } = require('discord-akairo');\r\nconst fetch =  require('node-fetch');\r\nconst qs = require('querystring');\r\n\r\nconst SOURCES = ['stable', 'master', 'rpc', 'commando', 'akairo', 'akairo-master'];\r\n\r\nclass DocsCommand extends Command {\r\n    constructor() {\r\n        super('docs', {\r\n            aliases: ['docs'],\r\n            category: 'docs',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            args: [\r\n                {\r\n                    id: 'query',\r\n                    match: 'rest',\r\n                    type: 'lowercase',\r\n                    prompt: {\r\n                        start: 'what would you like to search?'\r\n                    }\r\n                },\r\n                {\r\n                    id: 'force',\r\n                    match: 'flag',\r\n                    flag: ['--force', '-f']\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Searches discord.js documentation.',\r\n                usage: '<query>',\r\n                examples: ['TextChannel', 'Client', 'ClientUser#setActivity master']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { query, force }) {\r\n\r\n        query = query.split(' ');\r\n\t\t/*let project = 'main';\r\n\t\tlet branch = ['stable', 'master', 'rpc', 'commando'].includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tif (['rpc', 'commando'].includes(branch)) {\r\n\t\t\tproject = branch;\r\n\t\t\tbranch = 'master';\r\n\t\t}\r\n\t\tconst queryString = qs.stringify({ q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/${project}/${branch}/embed?${queryString}`);*/\r\n        const source = SOURCES.includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tconst queryString = qs.stringify({ src: source, q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/v2/embed?${queryString}`);\r\n\t\tconst data = await res.json();\r\n\t\tif (!data) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n        }\r\n        const newData = JSON.stringify(data).replace(/<p>|<\\/p>|<br>|<\\/br>/g, '');\r\n        const oldEmbed = JSON.parse(newData);\r\n        const embed = this.client.util.embed(oldEmbed)//.setColor(0x8387db).setDescription(data.description.replace(/<p>(.+)<\\/p>/g, '$1'))\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = DocsCommand;",
          "path": "src/commands/docs/docs.js"
        }
      }
    }
  },
  "classes": [],
  "interfaces": [],
  "typedefs": [],
  "externals": []
}