{"meta":{"generator":"0.2.0","format":19,"date":1555004817826},"custom":{"client":{"name":"client","files":{"Client":{"name":"Client","type":"js","content":"const { AkairoClient, CommandHandler, InhibitorHandler, ListenerHandler } = require('discord-akairo');\r\nconst { Counter, collectDefaultMetrics, register } = require('prom-client');\r\nconst SettingsProvider = require('../struct/SettingsProviders');\r\nconst MuteScheduler = require('../struct/MuteScheduler');\r\nconst ReactionRole = require('../models/ReactionRoles');\r\nconst { Client: Lavaqueue } = require('lavaqueue');\r\nconst { Collection, Util } = require('discord.js');\r\nconst Database = require('../struct/Database');\r\nconst Playlist = require('../models/Playlist');\r\nconst Setting = require('../models/settings');\r\nconst { createServer } = require('http');\r\nconst Case = require('../models/Case');\r\nconst { Rejects } = require('rejects');\r\nconst Tags = require('../models/Tags');\r\nconst { Op } = require('sequelize');\r\nconst { parse } = require('url');\r\nconst path = require('path');\r\n\r\nclass Client extends AkairoClient {\r\n\tconstructor(config) {\r\n\t\tsuper({ ownerID: config.owner }, {\r\n\t\t\tmessageCacheMaxSize: 50,\r\n\t\t\tmessageCacheLifetime: 300,\r\n\t\t\tmessageSweepInterval: 900,\r\n\t\t\tdisableEveryone: true,\r\n\t\t\tdisabledEvents: ['TYPING_START']\r\n\t\t});\r\n\r\n\t\tthis.commandHandler = new CommandHandler(this, {\r\n\t\t\tdirectory: path.join(__dirname, '..', 'commands'),\r\n\t\t\taliasReplacement: /-/g,\r\n\t\t\tprefix: message => this.settings.get(message.guild, 'prefix', '*'),\r\n\t\t\tallowMention: true,\r\n\t\t\tfetchMembers: true,\r\n\t\t\tcommandUtil: true,\r\n\t\t\tcommandUtilLifetime: 3e5,\r\n\t\t\tcommandUtilSweepInterval: 9e5,\r\n\t\t\thandleEdits: true,\r\n\t\t\tdefaultCooldown: 3000,\r\n\t\t\tdefaultPrompt: {\r\n\t\t\t\tmodifyStart: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\tmodifyRetry: (text, msg) => text && `${msg.author} **::** ${text}\\ntype \\`cancel\\` to cancel this command.`,\r\n\t\t\t\ttimeout: msg => `${msg.author} **::** Time ran out, command has been cancelled.`,\r\n\t\t\t\tended: msg => `${msg.author} **::** Too many retries, command has been cancelled.`,\r\n\t\t\t\tcancel: msg => `${msg.author} **::** Command has been cancelled.`,\r\n\t\t\t\tretries: 2,\r\n\t\t\t\ttime: 30000\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.inhibitorHandler = new InhibitorHandler(this, { directory: path.join(__dirname, '..', 'inhibitors') });\r\n\t\tthis.listenerHandler = new ListenerHandler(this, { directory: path.join(__dirname, '..', 'listeners') });\r\n\r\n\t\tthis.prometheus = {\r\n            messagesCounter: new Counter({ name: 'raven_messages_total', help: 'Total number of messages have seen' }),\r\n            commandCounter: new Counter({ name: 'raven_commands_total', help: 'Total number of commands used' }),\r\n            collectDefaultMetrics,\r\n            register\r\n        };\r\n        this.prometheus.collectDefaultMetrics({ prefix: 'raven_', timeout: 30000 });\r\n\r\n\t\tthis.music = new Lavaqueue({\r\n\t\t\tuserID: process.env.ID,\r\n\t\t\tpassword: process.env.PASS,\r\n\t\t\thosts: {\r\n\t\t\t\trest: process.env.REST,\r\n\t\t\t\tws: process.env.WS,\r\n\t\t\t\tredis: {\r\n\t\t\t\t\tport: process.env.PORT,\r\n\t\t\t\t\thost: process.env.HOST,\r\n\t\t\t\t\tdb: process.env.DB\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsend: async (guild, packet) => {\r\n\t\t\t\tconst shardGuild = this.guilds.get(guild);\r\n\t\t\t\tif (shardGuild) return shardGuild.shard.send(packet);\r\n\t\t\t\treturn Promise.resolve();\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tthis.config = config;\r\n\t\tthis.storage = new Rejects(this.music.queues.redis);\r\n\t\tthis.settings = new SettingsProvider(Setting);\r\n\t\tthis.muteScheduler = new MuteScheduler(this, Case);\r\n\t\tthis.starboards = new Collection();\r\n\t\tthis.cached = new Set();\r\n\r\n\t\tthis.commandHandler.resolver.addType('tag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn tag || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('existingTag', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst tag = await Tags.findOne({ where: { guildID: message.guild.id,\r\n\t\t\t\t[Op.or]: [\r\n\t\t\t\t\t{ name: phrase },\r\n\t\t\t\t\t{ aliases: { [Op.contains]: [phrase] } }\r\n\t\t\t\t]\r\n\t\t\t}});\r\n\r\n\t\t\treturn tag ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('tagContent', (phrase, message) => {\r\n\t\t\tif (!phrase) phrase = '';\r\n\t\t\tphrase = Util.cleanContent(phrase, message);\r\n\t\t\tif (message.attachments.first()) phrase += `\\n${message.attachments.first().url}`;\r\n\r\n\t\t\treturn phrase || null;\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.resolver.addType('reactionRole', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tconst msg = await ReactionRole.findOne({ where: { guildID: message.guild.id, messageID: phrase }});\r\n\t\t\treturn msg || null;\r\n\t\t})\r\n\r\n\t\tthis.commandHandler.resolver.addType('playlist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist || null;\r\n\t\t});\r\n\t\t\r\n\t\tthis.commandHandler.resolver.addType('existingPlaylist', async (phrase, message) => {\r\n\t\t\tif (!phrase) return null;\r\n\t\t\tphrase = Util.cleanContent(phrase.toLowerCase(), message);\r\n\t\t\tconst playlist = await Playlist.findOne({ where: { name: phrase, guildID: message.guild.id }});\r\n\r\n\t\t\treturn playlist ? null : phrase;\r\n\t\t});\r\n\r\n\t\tthis.setup();\r\n\r\n\t\t/*\r\n\t\tsetInterval(() => {\r\n\t\t\tfor (const guild of this.guilds.values()) {\r\n\t\t\t\tguild.presences.clear();\r\n\t\t\t}\r\n\t\t}, 900);\r\n\t\t*/\r\n\t}\r\n\r\n\tasync setup() {\r\n\t\tthis.commandHandler.useInhibitorHandler(this.inhibitorHandler);\r\n\t\tthis.commandHandler.useListenerHandler(this.listenerHandler);\r\n\t\tthis.listenerHandler.setEmitters({\r\n\t\t\tcommandHandler: this.commandHandler,\r\n\t\t\tinhibitorHandler: this.inhibitorHandler,\r\n\t\t\tlistenerHandler: this.listenerHandler\r\n\t\t});\r\n\r\n\t\tthis.commandHandler.loadAll();\r\n\t\tthis.inhibitorHandler.loadAll();\r\n\t\tthis.listenerHandler.loadAll();\r\n\t}\r\n\r\n\tasync metrics() {\r\n\t\tcreateServer((req, res) => {\r\n\t\t\tif (parse(req.url).pathname === '/metrics') {\r\n\t\t\t\tres.writeHead(200, { 'Content-Type': this.prometheus.register.contentType });\r\n\t\t\t\tres.write(this.prometheus.register.metrics());\r\n\t\t\t};\r\n\t\t\tres.end();\r\n\t\t}).listen(8080);\r\n    };\r\n\r\n\tasync start() {\r\n\t\tawait Database.authenticate();\r\n\t\tawait this.settings.init();\r\n\t\treturn this.login(this.config.token);\r\n\t}\r\n}\r\n\r\nmodule.exports = Client;\r\n","path":"src/client/Client.js"}}},"commands":{"name":"commands","files":{"docs":{"name":"docs","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst fetch =  require('node-fetch');\r\nconst qs = require('querystring');\r\n\r\nconst SOURCES = ['stable', 'master', 'rpc', 'commando', 'akairo', 'akairo-master'];\r\n\r\nclass DocsCommand extends Command {\r\n    constructor() {\r\n        super('docs', {\r\n            aliases: ['docs'],\r\n            category: 'docs',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            args: [\r\n                {\r\n                    id: 'query',\r\n                    match: 'rest',\r\n                    type: 'lowercase',\r\n                    prompt: {\r\n                        start: 'what would you like to search?'\r\n                    }\r\n                },\r\n                {\r\n                    id: 'force',\r\n                    match: 'flag',\r\n                    flag: ['--force', '-f']\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Searches discord.js documentation.',\r\n                usage: '<query>',\r\n                examples: ['TextChannel', 'Client', 'ClientUser#setActivity master']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { query, force }) {\r\n\r\n        query = query.split(' ');\r\n\t\t/*let project = 'main';\r\n\t\tlet branch = ['stable', 'master', 'rpc', 'commando'].includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tif (['rpc', 'commando'].includes(branch)) {\r\n\t\t\tproject = branch;\r\n\t\t\tbranch = 'master';\r\n\t\t}\r\n\t\tconst queryString = qs.stringify({ q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/${project}/${branch}/embed?${queryString}`);*/\r\n        const source = SOURCES.includes(query.slice(-1)[0]) ? query.pop() : 'stable';\r\n\t\tconst queryString = qs.stringify({ src: source, q: query.join(' '), force });\r\n        const res = await fetch(`https://djsdocs.sorta.moe/v2/embed?${queryString}`);\r\n\t\tconst data = await res.json();\r\n\t\tif (!data) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n        }\r\n        const newData = JSON.stringify(data).replace(/<p>|<\\/p>|<br>|<\\/br>/g, '');\r\n        const oldEmbed = JSON.parse(newData);\r\n        const embed = this.client.util.embed(oldEmbed)//.setColor(0x8387db).setDescription(data.description.replace(/<p>(.+)<\\/p>/g, '$1'))\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = DocsCommand;","path":"src/commands/docs/docs.js"},"npm":{"name":"npm","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst fetch = require('node-fetch');\r\nconst moment = require('moment'); require('moment-duration-format');\r\n\r\nclass NPMCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('npm', {\r\n\t\t\taliases: ['npm', 'npm-package'],\r\n\t\t\tcategory: 'docs',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'pkg',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: message => `${message.author}, what would you like to search for?`\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: pkg => pkg ? encodeURIComponent(pkg.replace(/ /g, '-')) : null\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Responds with information on an NPM package.',\r\n\t\t\t\tusage: '<query>',\r\n\t\t\t\texamples: ['discord.js', 'discord-akairo', 'node-fetch']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { pkg }) {\r\n\r\n\t\tconst res = await fetch(`https://registry.npmjs.com/${pkg}`);\r\n\t\tif (res.status === 404) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n\t\t}\r\n\t\tconst body = await res.json();\r\n\t\tif (body.time === undefined) {\r\n\t\t\treturn message.util.reply('commander of this package decided to unpublish it.');\r\n\t\t}\r\n\t\tconst version = body.versions[body['dist-tags'].latest];\r\n\t\tconst maintainers = this._trimArray(body.maintainers.map(user => user.name).join(', '));\r\n\t\tconst dependencies = version.dependencies ? this._trimArray(Object.keys(version.dependencies)) : '';\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t.setColor(0xCB0000)\r\n\t\t.setAuthor('NPM', 'https://i.imgur.com/ErKf5Y0.png', 'https://www.npmjs.com/')\r\n\t\t.setTitle(body.name)\r\n\t\t.setURL(`https://www.npmjs.com/package/${pkg}`)\r\n\t\t.setDescription(body.description || 'No description.')\r\n\t\t.addField('Version', body['dist-tags'].latest, true)\r\n\t\t.addField('License', body.license || 'None', true)\r\n\t\t.addField('Author', body.author ? body.author.name : '???', true)\r\n\t\t.addField('Creation Date', moment.utc(body.time.created).format('DD-MM-YYYY kk:mm:ss'), true)\r\n\t\t.addField('Modification Date', moment.utc(body.time.modified).format('DD-MM-YYYY kk:mm:ss'), true)\r\n\t\t.addField('Main File', version.main || 'index.js', true)\r\n\t\t.addField('Dependencies', dependencies && dependencies.length ? dependencies.join(', ') : 'None')\r\n\t\t.addField('Maintainers', maintainers);\r\n\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n\t}\r\n\r\n\t_trimArray(arr) {\r\n\t\tif (arr.length > 10) {\r\n\t\t\tconst len = arr.length - 10;\r\n\t\t\tarr = arr.slice(0, 10);\r\n\t\t}\r\n\t\treturn arr;\r\n\t}\r\n}\r\n\r\nmodule.exports = NPMCommand;","path":"src/commands/docs/npm.js"},"mdn":{"name":"mdn","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst fetch = require('node-fetch');\r\nconst qs = require('querystring');\r\nconst Turndown = require('turndown'); // eslint:disable-line\r\n\r\nclass MDNCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('mdn', {\r\n\t\t\taliases: ['mdn', 'mozilla-developer-network'],\r\n\t\t\tcategory: 'docs',\r\n\t\t\tregex: /^(?:mdn,) (.+)/i,\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'query',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: (message) => `${message.author}, what would you like to search for?`\r\n\t\t\t\t\t},\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: query => query ? query.replace(/#/g, '.prototype.') : null\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Searches MDN for your query.',\r\n\t\t\t\tusage: '<query>',\r\n\t\t\t\texamples: ['Map', 'Map#get', 'Map.set']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { query, match }) {\r\n\t\tif (!query && match) query = match[1];\r\n\t\tconst queryString = qs.stringify({ q: query });\r\n\t\tconst res = await fetch(`https://mdn.pleb.xyz/search?${queryString}`);\r\n\t\tconst body = await res.json();\r\n\t\tif (!body.URL || !body.Title || !body.Summary) {\r\n\t\t\treturn message.util.reply(\"I couldn't find the requested information.\");\r\n\t\t}\r\n\t\tconst turndown = new Turndown();\r\n\t\tturndown.addRule('hyperlink', {\r\n\t\t\tfilter: 'a',\r\n\t\t\treplacement: (text, node) => `[${text}](https://developer.mozilla.org${node.href})`\r\n\t\t});\r\n\t\tconst summary = body.Summary.replace(/<code><strong>(.+)<\\/strong><\\/code>/g, '<strong><code>$1<\\/code><\\/strong>');\r\n\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t.setColor(0x066FAD)\r\n\t\t.setAuthor('MDN', 'https://i.imgur.com/DFGXabG.png', 'https://developer.mozilla.org/')\r\n\t\t.setURL(`https://developer.mozilla.org${body.URL}`)\r\n\t\t.setTitle(body.Title)\r\n\t\t.setDescription(turndown.turndown(summary));\r\n\r\n\t\tif (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n\t}\r\n}\r\n\r\nmodule.exports = MDNCommand;","path":"src/commands/docs/mdn.js"},"about":{"name":"guide","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Akairo = require('discord-akairo');\r\nconst Discord = require('discord.js');\r\nconst fs = require('fs');\r\n\r\nclass AboutCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('about', {\r\n\t\t\taliases: ['about', 'info'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Shows information about the bot.' }\r\n\t\t});\r\n\t}\r\n\r\n\texec(message) {\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst owner = this.client.users.get(this.client.ownerID);\r\n\t\tconst raven = fs.readFileSync('file.txt', 'utf8');\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0x8387db)\r\n\t\t\t.setTitle(`About ${this.client.user.username}`)\r\n\t\t\t.addField('Dev', `**${this.client.user.username}** is developed by **[${owner.tag}](https://almostsuvajit.xyz)**`)\r\n\t\t\t.addField('Core', `[Discord.js](https://discord.js.org) (${Discord.version}) library and [Akairo](https://1computer1.github.io/discord-akairo) (${Akairo.version.replace(/beta.1/g, 'dev')}) framework`)\r\n\t\t\t.addField('Music', `[Lavalink](https://github.com/lavalibs/lavalink.js) audio player, along with [Lavaqueue](https://github.com/lavalibs/lavaqueue), backed by [Redis](https://github.com/MicrosoftArchive/redis) instance`)\r\n\t\t\t.addField('Database', `[PostgreSQL](https://www.postgresql.org/) database, along with [Sequelize](http://docs.sequelizejs.com/) [Node.js](https://nodejs.org/en/) ORM`)\r\n\t\t\t.addField('Host', [\r\n\t\t\t\t`[Amazon EC2](https://aws.amazon.com/ec2/)`,\r\n\t\t\t\t'```js',\r\n\t\t\t\t`${raven.toString()}`,\r\n\t\t\t\t'```'\r\n\t\t\t])\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = AboutCommand;\r\n","path":"src/commands/general/about.js"},"blacklist":{"name":"blacklist","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass BlacklistCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('blacklist', {\r\n\t\t\taliases: ['blacklist', 'unblacklist'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tuserPermissions: ['MANAGE_GUILD'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'member',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: 'member',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Which user do you want to blacklist or unblacklist?',\r\n\t\t\t\t\t\tretry: 'Please provide a valid user.'\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Blacklists or unblacklists someone from using stars and giving reputation.',\r\n\t\t\t\tusage: '<user>',\r\n\t\t\t\texamples: ['@BadPerson', 'someone#1234']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { member }) {\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\r\n\t\tif (blacklist.includes(member.id)) {\r\n\t\t\tconst index = blacklist.indexOf(member.id);\r\n\t\t\tblacklist.splice(index, 1);\r\n\t\t\tawait this.client.settings.set(message.guild, 'blacklist', blacklist);\r\n\r\n\t\t\treturn message.util.send(`**${member.user.tag}** has been removed from the blacklist.`);\r\n\t\t}\r\n\t\tblacklist.push(member.id);\r\n\t\tawait this.client.settings.set(message.guild, 'blacklist', blacklist);\r\n\r\n\t\treturn message.util.send(`**${member.user.tag}** has been blacklisted from using the starboard and giving reputation on this server.`);\r\n\t}\r\n}\r\n\r\nmodule.exports = BlacklistCommand;","path":"src/commands/general/blacklist.js"},"help":{"name":"help","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass HelpCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('help', {\r\n\t\t\taliases: ['help'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'command',\r\n\t\t\t\t\ttype: 'commandAlias',\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Which command do you need help with?',\r\n\t\t\t\t\t\tretry: 'Please provide a valid command.',\r\n\t\t\t\t\t\toptional: true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Displays a list of commands or information about a command.',\r\n\t\t\t\tusage: '[command]',\r\n\t\t\t\texamples: ['', 'star', 'remove-rep']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, { command }) {\r\n\t\tif (!command) return this.execCommandList(message);\r\n\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst description = Object.assign({\r\n\t\t\tcontent: 'No description available.',\r\n\t\t\tusage: '',\r\n\t\t\texamples: [],\r\n\t\t\tfields: []\r\n\t\t}, command.description);\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor('#8387db')\r\n\t\t\t.setTitle(`\\`${prefix}${command.aliases[0]} ${description.usage}\\``)\r\n\t\t\t.addField('Description', description.content);\r\n\r\n\t\tfor (const field of description.fields) embed.addField(field.name, field.value);\r\n\r\n\t\tif (description.examples.length) {\r\n\t\t\tconst text = `${prefix}${command.aliases[0]}`;\r\n\t\t\tembed.addField('Examples', `\\`${text} ${description.examples.join(`\\`\\n\\`${text} `)}\\``, true);\r\n\t\t}\r\n\r\n\t\tif (command.aliases.length > 1) {\r\n\t\t\tembed.addField('Aliases', `\\`${command.aliases.join('` `')}\\``, true);\r\n\t\t}\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n\r\n\tasync execCommandList(message) {\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor('#8387db')\r\n\t\t\t.addField('Command List', [\r\n\t\t\t\t`To view details for a command, do \\`*help <command>\\``\r\n\t\t\t]);\r\n\r\n\t\tfor (const category of this.handler.categories.values()) {\r\n\t\t\tconst title = {\r\n\t\t\t\tgeneral: '\\u2000General',\r\n\t\t\t\treputation: '\\u2000Reputation',\r\n\t\t\t\tstarboard: '\\u2000Starboard',\r\n\t\t\t\tdocs: '\\u2000Docs',\r\n\t\t\t\tinfo: '\\u2000Info',\r\n\t\t\t\ttags: '\\u200bTags',\r\n\t\t\t\tmusic: '\\u200bMusic',\r\n\t\t\t\tmod: '\\u200bMod',\r\n\t\t\t\tconfig: '\\u200bConfig',\r\n\t\t\t\tfun: '\\u200bFun'\r\n\t\t\t}[category.id];\r\n\r\n\t\t\tif (title) embed.addField(title, `${category.filter(cmd => cmd.aliases.length > 0).map(cmd => `\\`${cmd.aliases[0]}\\``).join(' ')}`);\r\n\t\t}\r\n\r\n\t\tconst shouldReply = message.guild && message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES');\r\n\r\n\t\ttry {\r\n\t\t\tawait message.author.send({ embed });\r\n\t\t\tif (shouldReply) return message.util.reply('I\\'ve sent you a DM with the command list.');\r\n\t\t} catch (err) {\r\n\t\t\tif (shouldReply) return message.util.reply('I could not send you the command list in DMs.');\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n}\r\n\r\nmodule.exports = HelpCommand;","path":"src/commands/general/help.js"},"invite":{"name":"invite","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass InviteCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('invite', {\r\n\t\t\taliases: ['invite'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Gets the bot invite link.' }\r\n\t\t});\r\n\t}\r\n\r\n\tasync fetchInvite() {\r\n\t\tif (this.invite) return this.invite;\r\n\t\tconst invite = await this.client.generateInvite([\r\n\t\t\t'ADMINISTRATOR',\r\n\t\t\t'VIEW_CHANNEL',\r\n\t\t\t'MANAGE_MESSAGES',\r\n\t\t\t'READ_MESSAGE_HISTORY',\r\n\t\t\t'SEND_MESSAGES',\r\n\t\t\t'EMBED_LINKS'\r\n\t\t]);\r\n\r\n\t\tthis.invite = invite;\r\n\t\treturn invite;\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0xFFAC33)\r\n\t\t\t.setTitle(`**Invite ${this.client.user.username} to your server!**`).setURL(`${await this.fetchInvite()}`);\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = InviteCommand;","path":"src/commands/general/invite.js"},"ping":{"name":"ping","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nconst RESPONSES = [\r\n\t'No...',\r\n\t'Not Happening...',\r\n\t'Maybe Later...',\r\n\t`Pong! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Just you know, I'm not doing this for fun! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Don't think this means anything special! \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``,\r\n\t`Can we get on with this already? \\`$(ping)ms\\` :: \\`$(heartbeat)ms\\``\r\n];\r\n\r\nclass PingCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('ping', {\r\n\t\t\taliases: ['ping', 'pong'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tdescription: { content: `Pings me!` }\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst msg = await message.util.send('Pinging...');\r\n\r\n\t\treturn message.util.send(\r\n\t\t\tRESPONSES[Math.floor(Math.random() * RESPONSES.length)]\r\n\t\t\t.replace('$(ping)', ((msg.editedTimestamp || msg.createdTimestamp) - (message.editedTimestamp || message.createdTimestamp)).toString())\r\n\t\t\t.replace('$(heartbeat)', Math.round(this.client.ws.ping).toString())\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule.exports = PingCommand;","path":"src/commands/general/ping.js"},"prefix":{"name":"prefix","type":"js","content":"const { Argument, Command, Control } = require('discord-akairo');\r\n\r\nclass PrefixCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('prefix', {\r\n\t\t\taliases: ['prefix'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'method',\r\n\t\t\t\t},\r\n\t\t\t\tControl.if((msg, args) => msg.member.roles.has(this.client.settings.get(msg.guild, 'modRole', undefined)) && args.method, [\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tid: 'prefix',\r\n\t\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\t\ttype: Argument.validate('string', p => !/\\s/.test(p) && p.length <= 5),\r\n\t\t\t\t\t\tdefault: '',\r\n\t\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\t\tretry: `Please provide a prefix without spaces and less than 5 characters`\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t])\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: [\r\n\t\t\t\t\t'Displays or changes the prefix of the guild.',\r\n\t\t\t\t\t'The prefix must not contain spaces and be below 5 characters.'\r\n\t\t\t\t],\r\n\t\t\t\tusage: '<prefix>',\r\n\t\t\t\texamples: ['!', '?']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { prefix }) {\r\n\r\n\t\tif (!prefix) return message.util.send(`The current prefix for this guild is: \\`${this.handler.prefix(message)}\\``);\r\n\t\tthis.client.settings.set(message.guild, 'prefix', prefix);\r\n\t\tif (prefix === this.handler.prefix(message)) {\r\n\t\t\treturn message.util.reply(`the prefix has been reset to \\`${prefix}\\``);\r\n\t\t}\r\n\t\treturn message.util.reply(`the prefix has been set to \\`${prefix}\\``);\r\n\t}\r\n}\r\n\r\nmodule.exports = PrefixCommand;","path":"src/commands/general/prefix.js"},"reset":{"name":"reset","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst Reputation = require('../../models/reputations');\r\n\r\nclass ResetCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('reset', {\r\n\t\t\taliases: ['reset'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tuserPermissions: ['MANAGE_GUILD'],\r\n\t\t\tquoted: false,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'mode',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: [['stars', 'star'], ['reps', 'rep'], 'all'],\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: 'Please choose an item to reset: `stars`, `reps`, `all`.',\r\n\t\t\t\t\t\tretry: [\r\n\t\t\t\t\t\t\t'Please provide a valid reset item.',\r\n\t\t\t\t\t\t\t'Choose one of `stars`, `reps` or `all`.'\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'confirm',\r\n\t\t\t\t\tmatch: 'none',\r\n\t\t\t\t\ttype: phrase => {\r\n\t\t\t\t\t\tif (!phrase) return null;\r\n\r\n\t\t\t\t\t\t// Yes, yea, ye, or y.\r\n\t\t\t\t\t\tif (/^y(?:e(?:a|s)?)?$/i.test(phrase)) return true;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: (msg, { mode }) => `${{\r\n\t\t\t\t\t\t\tstars: 'Are you sure you want to reset all stars on this server? (y/N)',\r\n\t\t\t\t\t\t\treps: 'Are you sure you want to reset all reputation points on this server? (y/N)',\r\n\t\t\t\t\t\t\tall: 'Are you sure you want to reset all stars and reputation points on this server? (y/N)'\r\n\t\t\t\t\t\t}[mode]}`,\r\n\t\t\t\t\t\tretry: ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Resets the stars and/or reputations of the guild.',\r\n\t\t\t\tusage: '<mode>',\r\n\t\t\t\texamples: ['stars', 'reps', 'all']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { mode, confirm }) {\r\n\t\tif (!confirm) {\r\n\t\t\treturn message.util.send('Reset has been cancelled.');\r\n\t\t}\r\n\r\n\t\tif (mode === 'stars' || mode === 'all') await this.client.starboards.get(message.guild.id).destroy();\r\n\t\tif (mode === 'reps' || mode === 'all') await Reputation.destroy({ where: { guildID: message.guild.id } });\r\n\r\n\t\treturn message.util.send(`${message.author} **::** ${{\r\n\t\t\tstars: 'Successfully removed all starred messages on this server.',\r\n\t\t\treps: 'Successfully removed all reputation points on this server.',\r\n\t\t\tall: 'Successfully removed all starred messages and reputation points on this server.'\r\n\t\t}[mode]}`);\r\n\t}\r\n}\r\n\r\nmodule.exports = ResetCommand;","path":"src/commands/general/reset.js"},"settings":{"name":"settings","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst ReactionRole = require('../../models/ReactionRoles');\r\n\r\nclass SettingsCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('settings', {\r\n\t\t\taliases: ['settings', 'view-settings'],\r\n\t\t\tcategory: 'general',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tdescription: { content: 'Displays the guild\\'s current settings.' }\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tconst prefix = this.handler.prefix(message);\r\n\t\tconst starboard = this.client.starboards.get(message.guild.id);\r\n\t\tconst guildlog = this.client.settings.get(message.guild, 'guildLog', undefined);\r\n\t\tconst modlog = this.client.settings.get(message.guild, 'modLogChannel', undefined);\r\n\t\tconst memberlog = this.client.settings.get(message.guild, 'memberLog', undefined);\r\n\t\tconst modrole = this.client.settings.get(message.guild, 'modRole', undefined);\r\n\t\tconst blacklist = this.client.settings.get(message.guild, 'blacklist', []);\r\n\r\n\t\tconst toBeDeleted = await ReactionRole.findAll({ where: { guildID: message.guild.id }});\r\n\t\tfor (const channel of toBeDeleted) {\r\n\t\t\tif (!this.client.channels.has(channel.channelID)) {\r\n\t\t\t\tawait ReactionRole.destroy({ where: { guildID: message.guild.id, channelID: channel.channelID }});\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst allReaction = await ReactionRole.findAll({ where: { guildID: message.guild.id }});\r\n\t\tconst data = await Promise.all(allReaction.map(async row => {\r\n\t\t\tconst channel = await this.client.channels.get(row.channelID);\r\n\t\t\tconst msg = await channel.messages.fetch(row.messageID).catch(() => ( { msg: row.messageID } ));\r\n\t\t\treturn { channel: channel, message: msg, emoji: row.emoji, role: row.roleID };\r\n\t\t}))\r\n\r\n\t\tconst embed = this.client.util.embed()\r\n\t\t\t.setColor(0xFFAC33)\r\n\t\t\t.setTitle('Settings')\r\n\t\t\t.setDescription([\r\n\t\t\t\t`**Prefix**: \\`${prefix}\\``,\r\n\t\t\t\t`**Starboard**: ${(starboard && starboard.channel) || 'None'}`,\r\n\t\t\t\t`**GuildLog**: ${message.guild.channels.get(guildlog) || 'None'}`,\r\n\t\t\t\t`**ModLog**: ${message.guild.channels.get(modlog) || 'None'}`,\r\n\t\t\t\t`**MemberLog**: ${message.guild.channels.get(memberlog) || 'None'}`,\r\n\t\t\t\t`**Mod Role**: ${message.guild.roles.get(modrole) || 'None'}`,\r\n\t\t\t\t`**Moderation**: ${this.client.settings.get(message.guild, 'moderation', undefined)}`,\r\n\t\t\t\t`**Role State**: ${this.client.settings.get(message.guild, 'roleState', undefined)}`,\r\n\t\t\t\t`**Threshold**: ${(starboard && starboard.threshold) || 'None'}`,\r\n\t\t\t\t`**Blacklist**: ${blacklist.join(', ') || 'None'}`\r\n\t\t\t]);\r\n\t\tif (data.length) {\r\n\t\t\tconst desc = data.map(({ channel, message, emoji, role }, index) => `${1 + index}. \\\\${emoji} ${message.url ? `[Jump To](${message.url}) ${channel} <@&${role}>` : `${message.msg} (msg deleted)` }`)\r\n\t\t\tembed.addField('Reaction Roles', desc)\r\n\t\t}\r\n\r\n\t\treturn message.util.send({ embed });\r\n\t}\r\n}\r\n\r\nmodule.exports = SettingsCommand;","path":"src/commands/general/settings.js"},"stats":{"name":"stats","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst { MessageEmbed } = require('discord.js');\r\nconst os = require('os-utils');\r\nconst moment = require('moment'); require('moment-duration-format');\r\nconst { version } = require('../../../package.json');\r\n\r\nclass StatsCommand extends Command {\r\n    constructor() {\r\n        super('stats', {\r\n            aliases: ['stats'],\r\n            category: 'general',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            ratelimit: 2,\r\n            description: { content: 'Displays statistics about the bot' }\r\n        });\r\n    }\r\n\r\n    async exec(message) {\r\n        const embed = new MessageEmbed().setColor('#8387db').setTitle(`${this.client.user.username} Statistics`)\r\n        .setThumbnail(this.client.user.displayAvatarURL())\r\n        .setURL(`http://raven.almostsuvajit.xyz/metrics`)\r\n        .addField(\"❯ Memory Usage\", [\r\n            `• Using : ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} MB`,\r\n            `• Free : ${Math.round(os.freemem())} MB`\r\n        ], true) \r\n        .addField(\"❯ Uptime\", `• ${moment.duration(this.client.uptime).format(\"M [months], W [weeks], D [days], H [hrs], m [mins], s [secs]\")}`, true)\r\n        .addField(\"❯ General Stats\", [\r\n            `• Users : ${this.client.users.size}`,\r\n            `• Channels : ${this.client.channels.size}`\r\n        ], true)\r\n        .addField('❯ Version', `• [v${version}](https://github.com/isuvajit/raven)`, true)\r\n        .addField(\"❯ Library\", `• [discord.js](https://discord.js.org)[-akairo](https://github.com/discord-akairo/discord-akairo)`, true)\r\n        .setFooter('© 2018 ' + this.client.users.get(this.client.ownerID).tag, this.client.users.get(this.client.ownerID).displayAvatarURL())\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n        const msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = StatsCommand;","path":"src/commands/general/stats.js"},"uptime":{"name":"uptime","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment'); require('moment-duration-format');\r\n\r\nclass UptimeCommand extends Command {\r\n    constructor() {\r\n        super('uptime', {\r\n            aliases: ['uptime'],\r\n            category: 'general',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            description: {\r\n                content: 'Displayes uptime of the bot.'\r\n            }\r\n        })\r\n    }\r\n\r\n    exec(message) {\r\n        const duration = moment.duration(this.client.uptime).format(\"M [months], W [weeks], D [days], H [hrs], m [mins], s [secs]\");\r\n        const embed = this.client.util.embed()\r\n        .setAuthor(duration).setColor(0x8387db)\r\n        \r\n        return message.util.send({ embed });\r\n    }\r\n}\r\n\r\nmodule.exports = UptimeCommand;","path":"src/commands/general/uptime.js"},"avatar":{"name":"avatar","type":"js","content":"const { Command } = require('discord-akairo');\r\n\r\nclass AvatarCommand extends Command {\r\n    constructor() {\r\n        super('avatar', {\r\n            aliases: ['avatar'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'member',\r\n                    type: 'member',\r\n                    default: message => message.member\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Displays avatar of a member.',\r\n                usage: '<member>',\r\n                examples: ['@Suvajit', 'Suvajit', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { member }) {\r\n\r\n        const embed = this.client.util.embed().setColor('RANDOM')\r\n        .setAuthor(member.user.tag)\r\n        .setImage(member.user.avatarURL({ size: 2048 }))\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n            msg.reactions.removeAll();\r\n            \r\n\t\t\treturn message;\r\n\t\t}\r\n        react.first().message.delete();\r\n        \r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = AvatarCommand;","path":"src/commands/info/avatar.js"},"channel":{"name":"channel","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nclass ChannelInfoCommand extends Command {\r\n    constructor() {\r\n        super('channelinfo', {\r\n            aliases: ['channel', 'channel-info'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS', 'MANAGE_CHANNELS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'channel',\r\n                    type: 'channel',\r\n                    default: message => message.channel\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a channel.',\r\n                usage: '<channel>',\r\n                examples: ['#general', 'bot-commands', '544374591305285632']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { channel }) {\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`#${channel.name} (${channel.id})`)\r\n        .setThumbnail(message.guild.iconURL())\r\n        .addField('❯ Info', [\r\n            `${channel.topic ? `• Topic: ${channel.topic}` : ''}`,\r\n            `• Type: ${channel.type.toUpperCase()}`,\r\n            `• NSFW: ${channel.nsfw ? 'Yes' : 'No'}`,\r\n            `• Creation Date: ${moment(channel.createdAt).format('D-MM-YY, k:mm:ss')}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = ChannelInfoCommand;","path":"src/commands/info/channel.js"},"emoji":{"name":"emoji","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\nconst { MessageEmbed, GuildEmoji } = require('discord.js');\r\nconst emojis = require('node-emoji');\r\nconst punycode = require('punycode');\r\n\r\nconst EMOJI_REGEX = /<:\\w+:(\\d{17,19})>/;\r\n\r\nclass EmojiInfoCommand extends Command {\r\n\tconstructor() {\r\n\t\tsuper('emoji', {\r\n\t\t\taliases: ['emoji', 'emoji-info'],\r\n\t\t\tcategory: 'info',\r\n\t\t\tchannel: 'guild',\r\n\t\t\tclientPermissions: ['EMBED_LINKS'],\r\n\t\t\tratelimit: 2,\r\n\t\t\targs: [\r\n\t\t\t\t{\r\n\t\t\t\t\tid: 'emoji',\r\n\t\t\t\t\tmatch: 'content',\r\n\t\t\t\t\ttype: (content, message) => {\r\n\t\t\t\t\t\tif (EMOJI_REGEX.test(content)) [, content] = content.match(EMOJI_REGEX);\r\n\t\t\t\t\t\tif (!isNaN(content)) return message.guild.emojis.get(content);\r\n\t\t\t\t\t\tconst emoji = emojis.find(content);\r\n\t\t\t\t\t\tif (emoji) return emoji;\r\n\t\t\t\t\t\treturn message.guild.emojis.find(e => e.name === content);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tprompt: {\r\n\t\t\t\t\t\tstart: `what emoji would you like information about?`,\r\n\t\t\t\t\t\tretry: `please provide a valid emoji!`\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\tdescription: {\r\n\t\t\t\tcontent: 'Get information about an emoji.',\r\n\t\t\t\tusage: '<emoji>',\r\n\t\t\t\texamples: ['🤔', 'thinking_face', '264701195573133315', '<:Thonk:264701195573133315>']\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, { emoji }) {\r\n\t\tconst embed = new MessageEmbed()\r\n\t\t\t.setColor(3447003);\r\n\r\n\t\tif (emoji instanceof GuildEmoji) {\r\n\t\t\tembed.setDescription(`Info about ${emoji.name} (ID: ${emoji.id})`);\r\n\t\t\tembed.setThumbnail(emoji.url);\r\n\t\t\tembed.addField('❯ Info', [\r\n\t\t\t\t`• Identifier: \\`<${emoji.animated ? '' : ':'}${emoji.identifier}>\\``,\r\n\t\t\t\t`• Creation Date: ${moment.utc(emoji.createdAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n\t\t\t\t`• URL: ${emoji.url}`\r\n\t\t\t]);\r\n\t\t} else {\r\n\t\t\tembed.setDescription(`Info about ${emoji.emoji}`);\r\n\t\t\tembed.addField('❯ Info', [\r\n\t\t\t\t`• Name: ${emoji.key}`,\r\n\t\t\t\t`• Raw: \\\\${emoji.emoji}`,\r\n\t\t\t\t`• Unicode: \\`${punycode.ucs2.decode(emoji.emoji).map(e => `\\\\u${e.toString(16).toUpperCase().padStart(4, '0')}`).join('')}\\``\r\n\t\t\t]);\r\n\t\t}\r\n\r\n\t\treturn message.util.send(embed);\r\n\t}\r\n}\r\n\r\nmodule.exports = EmojiInfoCommand;","path":"src/commands/info/emoji.js"},"roleinfo":{"name":"role-info","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nconst PERMISSIONS = ({\r\n    ADMINISTRATOR: 'Administrator',\r\n    VIEW_AUDIT_LOG: 'View Audit Log',\r\n    MANAGE_GUILD: 'Manage Server',\r\n    MANAGE_ROLES: 'Manage Roles',\r\n    MANAGE_CHANNELS: 'Manage Channels',\r\n    KICK_MEMBERS: 'Kick Members',\r\n    BAN_MEMBERS: 'Ban Members',\r\n    CREATE_INSTANT_INVITE: 'Create Instant Invite',\r\n    CHANGE_NICKNAME: 'Change Nickname',\r\n    MANAGE_NICKNAMES: 'Manage Nicknames',\r\n    MANAGE_EMOJIS: 'Manage Emojis',\r\n    MANAGE_WEBHOOKS: 'Manage Webhooks',\r\n    VIEW_CHANNEL: 'Read Text & See Voice Channels',\r\n    SEND_MESSAGES: 'Send Messages',\r\n    SEND_TTS_MESSAGES: 'Send TTS Messages',\r\n    MANAGE_MESSAGES: 'Manage Messages',\r\n    EMBED_LINKS: 'Embed Links',\r\n    ATTACH_FILES: 'Attach Files',\r\n    READ_MESSAGE_HISTORY: 'Read Message History',\r\n    MENTION_EVERYONE: 'Mention Everyone',\r\n    USE_EXTERNAL_EMOJIS: 'Use External Emojis',\r\n    ADD_REACTIONS: 'Add Reactions',\r\n    CONNECT: 'Connect',\r\n    SPEAK: 'Speak',\r\n    MUTE_MEMBERS: 'Mute Members',\r\n    DEAFEN_MEMBERS: 'Deafen Members',\r\n    MOVE_MEMBERS: 'Move Members',\r\n    USE_VAD: 'Use Voice Activity'\r\n})\r\n\r\nclass RoleInfoCommad extends Command {\r\n    constructor() {\r\n        super('roleinfo', {\r\n            aliases: ['roleinfo'],\r\n            category: 'info',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            channel: 'guild',\r\n            args: [\r\n                {\r\n                    id: 'role',\r\n                    type: 'role',\r\n                    default: message => message.member.roles.highest\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a role.',\r\n                usage: '<role>',\r\n                examples: ['Admin', '@Staff', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { role }) {\r\n\r\n        const permissions = Object.keys(PERMISSIONS).filter(permission => role.permissions.serialize()[permission]);\r\n        const permission = permissions.map(permission => `• ${PERMISSIONS[permission]}`).join('\\n')\r\n\r\n        const embed = this.client.util.embed().setColor(role.hexColor)\r\n        .setAuthor(`${role.name} (${role.id})`)\r\n        .addField('❯ Info', [\r\n            `• Color: ${role.hexColor.toUpperCase()}`,\r\n            `• Hoisted: ${role.hoist ? 'Yes' : 'No'}`,\r\n            `• Mentionable: ${role.mentionable ? 'Yes' : 'No'}`,\r\n            `• Creation Date: ${moment.utc(role.createdAt).format('DD-MM-YY kk:mm:ss')}`\r\n        ])\r\n        .addField('❯ Permissions', `${permission.length === 487 ? '• Administrator' : permission || '• None' }`)\r\n        .setThumbnail(message.guild.iconURL())\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    } \r\n}\r\n\r\nmodule.exports = RoleInfoCommad;","path":"src/commands/info/roleinfo.js"},"server":{"name":"server","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nconst HUMAN_LEVELS = ({\r\n\t0: 'None',\r\n\t1: 'Low',\r\n\t2: 'Medium',\r\n\t3: '(╯°□°）╯︵ ┻━┻',\r\n\t4: '┻━┻ ﾐヽ(ಠ益ಠ)ノ彡┻━┻'\r\n});\r\n\r\nclass ServerInfoCommand extends Command {\r\n    constructor() {\r\n        super('serverinfo', {\r\n            aliases: ['serverinfo', 'server', 'guild'],\r\n            category: 'info',\r\n            channel: 'guild',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            description: { content: 'Get info on the server.' },\r\n        })\r\n    }\r\n\r\n    async exec(message) {\r\n        const members = await message.guild.members.fetch();\r\n\t\tconst bot = members.filter(m => m.user.bot).size;\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`${message.guild.name} (${message.guild.id})`, message.guild.iconURL())\r\n        .setThumbnail(message.guild.iconURL())\r\n        .addField('❯ General Info', [\r\n            `• Members: ${message.guild.memberCount}`,\r\n            `• Bots: ${bot}`,\r\n            `• Roles: ${message.guild.roles.size}`\r\n        ])\r\n        .addField('❯ Channels Info', [\r\n            `• Text: ${message.guild.channels.filter(ch => ch.type === 'text').size}`,\r\n            `• Voice: ${message.guild.channels.filter(ch => ch.type === 'voice').size}`,\r\n            `• AFK: ${message.guild.afkChannelID ? `<#${message.guild.afkChannelID}> after ${message.guild.afkTimeout / 60} min` : 'None'}`\r\n        ])\r\n        .addField('❯ Other', [\r\n            `• Region: ${message.guild.region.toUpperCase()}`,\r\n            `• Created at: ${moment.utc(message.guild.createdAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Owner: ${message.guild.owner.user.tag} (${message.guild.ownerID})`,\r\n            `• Verification Level: ${HUMAN_LEVELS[message.guild.verificationLevel]}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = ServerInfoCommand;","path":"src/commands/info/server.js"},"userinfo":{"name":"user","type":"js","content":"const { Command } = require('discord-akairo');\r\nconst moment = require('moment');\r\n\r\nclass UserCommand extends Command {\r\n    constructor() {\r\n        super('user', {\r\n            aliases: ['user'],\r\n            category: 'info',\r\n            channel: 'guild',\r\n            clientPermissions: ['EMBED_LINKS'],\r\n            args: [\r\n                {\r\n                    id: 'member',\r\n                    type: 'member',\r\n                    default: message => message.member\r\n                }\r\n            ],\r\n            description: {\r\n                content: 'Get info about a member.',\r\n                usage: '<member>',\r\n                examples: ['@Suvajit', 'Suvajit', '444432489818357760']\r\n            }\r\n        })\r\n    }\r\n\r\n    async exec(message, { member }) {\r\n\r\n        const { user } = member;\r\n\r\n        const embed = this.client.util.embed().setColor('RED')\r\n        .setAuthor(`${member.user.tag} (${member.user.id})`, user.displayAvatarURL())\r\n        .setThumbnail(user.displayAvatarURL())\r\n        .addField('❯ Member Details', [\r\n            `${member.nickname ? `• Nickname: ${member.nickname}` : ''}`,\r\n            `• Joined at: ${moment.utc(member.joinedAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Role: ${member.roles.map(role=> `*${role}*`).join(', ')}`\r\n        ])\r\n        .addField('❯ User Details', [\r\n            `${user.bot ? `• Bot Account` : ''}`,\r\n            `• ID: ${user.id}`,\r\n            `• Created at: ${moment.utc(user.createdAt).format('DD/MM/YYYY kk:mm:ss')}`,\r\n            `• Status: ${user.presence.status.toUpperCase()}`,\r\n            `• Activity: ${user.presence.activity ? user.presence.activity.name : 'None'}`\r\n        ])\r\n\r\n        if (message.channel.type === 'dm' || !(message.channel).permissionsFor(message.guild.me).has(['ADD_REACTIONS', 'MANAGE_MESSAGES'], false)) {\r\n\t\t\treturn message.util.send({ embed });\r\n\t\t}\r\n\t\tconst msg = await message.util.send({ embed });\r\n\t\tmsg.react('🗑');\r\n\t\tlet react;\r\n\t\ttry {\r\n\t\t\treact = await msg.awaitReactions(\r\n\t\t\t\t(reaction, user) => reaction.emoji.name === '🗑' && user.id === message.author.id,\r\n\t\t\t\t{ max: 1, time: 30000, errors: ['time'] }\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tmsg.reactions.removeAll();\r\n\r\n\t\t\treturn message;\r\n\t\t}\r\n\t\treact.first().message.delete();\r\n\r\n\t\treturn message;\r\n    }\r\n}\r\n\r\nmodule.exports = UserCommand;","path":"src/commands/info/userinfo.js"}}},"listeners":{"name":"Listeners","files":{"commandBlocked":{"name":"commandBlocked","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass CommandBlockedListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('commandBlocked', {\r\n\t\t\tevent: 'commandBlocked',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, reason) {\r\n\t\tconst text = {\r\n\t\t\towner: () => 'You must be the owner to use this command.',\r\n\t\t\tguild: () => 'You must be in a guild to use this command.'\r\n\t\t}[reason];\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${reason}`, { tag });\r\n\r\n\t\tif (!text) return;\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(text());\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = CommandBlockedListener;","path":"src/listeners/commandHandler/commandBlocked.js"},"commandStarted":{"name":"commandStarted","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\nconst Raven = require('raven');\r\nconst Levels = require('../../models/UserLevel');\r\nconst Commands = require('../../models/Commands');\r\n\r\nclass CommandStartedListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('commandStarted', {\r\n\t\t\tevent: 'commandStarted',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message, command, args) {\r\n\t\tthis.client.prometheus.commandCounter.inc();\r\n\r\n\t\tif (message.guild && command.categoryID && command.categoryID !== 'owner') {\r\n\t\t\tconst _command = await Commands.findOne({ where: { guildID: message.guild.id, commandID: command.id }});\r\n\t\t\tif (_command) {\r\n\t\t\t\tawait Commands.update({\r\n\t\t\t\t\tuses: _command.uses + 1, categoryID: command.categoryID,\r\n\t\t\t\t\tcommandAlias: command.aliases ? command.aliases[0] : command.id\r\n\t\t\t\t}, { where: { guildID: message.guild.id, commandID: command.id }});\r\n\r\n\t\t\t} else await Commands.create({\r\n\t\t\t\tcommandID: command.id, guildID: message.guild.id, uses: 1, categoryID: command.categoryID,\r\n\t\t\t\tcommandAlias: command.aliases ? command.aliases[0] : command.id\r\n\t\t\t});\r\n\r\n\t\t\tif (command.id === 'tag-show') {\r\n\t\t\t\tconst _user = await Levels.findOne({ where: { guildID: message.guild.id, userID: message.author.id }});\r\n\t\t\t\tif (_user) {\r\n\t\t\t\t\tawait Levels.update({\r\n\t\t\t\t\t\ttagUses: _user.tagUses + 1\r\n\t\t\t\t\t}, { where: { guildID: message.guild.id, userID: message.author.id }});\r\n\r\n\t\t\t\t} else await Levels.create({ guildID: message.guild.id, userID: message.author.id, tagUses: 1 });\r\n\r\n\t\t\t} else if (command.categoryID !== 'tags') {\r\n\t\t\t\tconst _user = await Levels.findOne({ where: { guildID: message.guild.id, userID: message.author.id }});\r\n\t\t\t\tif (_user) {\r\n\t\t\t\t\tawait Levels.update({\r\n\t\t\t\t\t\tcommandUses: _user.commandUses + 1\r\n\t\t\t\t\t}, { where: { guildID: message.guild.id, userID: message.author.id }});\r\n\r\n\t\t\t\t} else await Levels.create({ guildID: message.guild.id, userID: message.author.id, commandUses: 1 });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} - ${message.author.tag}` : `${message.author.tag}`;\r\n\t\tLogger.log(`=> ${command.id}`, { tag });\r\n\r\n\t\tRaven.captureBreadcrumb({\r\n\t\t\tmessage: 'command_started',\r\n\t\t\tcategory: command.category.id,\r\n\t\t\tdata: {\r\n\t\t\t\tuser: {\r\n\t\t\t\t\tid: message.author.id,\r\n\t\t\t\t\tusername: message.author.tag\r\n\t\t\t\t},\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t},\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t},\r\n\t\t\t\targs\r\n\t\t\t}\r\n\t\t});\r\n\t\tRaven.setContext({\r\n\t\t\tuser: {\r\n\t\t\t\tid: message.author.id,\r\n\t\t\t\tusername: message.author.tag\r\n\t\t\t},\r\n\t\t\textra: {\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t},\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t},\r\n\t\t\t\targs\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = CommandStartedListener;","path":"src/listeners/commandHandler/commandStarted.js"},"cooldown":{"name":"cooldown","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass CooldownListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('cooldown', {\r\n\t\t\tevent: 'cooldown',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, remaining) {\r\n\t\tconst time = remaining / 1000;\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${time}`, { tag });\r\n\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(`You can use that command again in ${time} seconds.`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = CooldownListener;","path":"src/listeners/commandHandler/cooldown.js"},"error":{"name":"error","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\nconst Raven = require('raven');\r\n\r\nclass ErrorListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('error', {\r\n\t\t\tevent: 'error',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(error, message, command) {\r\n\r\n\t\tLogger.error('An error occured in a command.');\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.error(message.content, { tag });\r\n\t\tLogger.stacktrace(error);\r\n\r\n\t\tRaven.captureBreadcrumb({\r\n\t\t\tmessage: 'command_errored',\r\n\t\t\tcategory: command ? command.category.id : 'inhibitor',\r\n\t\t\tdata: {\r\n\t\t\t\tuser: {\r\n\t\t\t\t\tid: message.author.id,\r\n\t\t\t\t\tusername: message.author.tag\r\n\t\t\t\t},\r\n\t\t\t\tguild: message.guild ? {\r\n\t\t\t\t\tid: message.guild.id,\r\n\t\t\t\t\tname: message.guild.name\r\n\t\t\t\t} : null,\r\n\t\t\t\tcommand: command ? {\r\n\t\t\t\t\tid: command.id,\r\n\t\t\t\t\taliases: command.aliases,\r\n\t\t\t\t\tcategory: command.category.id\r\n\t\t\t\t} : null,\r\n\t\t\t\tmessage: {\r\n\t\t\t\t\tid: message.id,\r\n\t\t\t\t\tcontent: message.content\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tRaven.captureException(error);\r\n\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tconst owner = this.client.users.get(this.client.ownerID).tag;\r\n\t\t\tmessage.channel.send([\r\n\t\t\t\t'```js',\r\n\t\t\t\terror.toString(),\r\n\t\t\t\t'```'\r\n\t\t\t]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = ErrorListener;","path":"src/listeners/commandHandler/error.js"},"messageInvalid":{"name":"messageInvalid","type":"js","content":"const { Listener } = require('discord-akairo');\r\n\r\nclass MessageInvalidListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('messageInvalid', {\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tevent: 'messageInvalid',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\tasync exec(message) {\r\n\t\tif (message.guild && message.util.parsed.prefix) {\r\n\t\t\tif (!message.util.parsed.alias || !message.util.parsed.afterPrefix) return;\r\n\t\t\tconst command = this.client.commandHandler.modules.get('tag-show');\r\n\t\t\t\r\n\t\t\treturn this.client.commandHandler.runCommand(message, command, await command.parse(message, message.util.parsed.afterPrefix));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = MessageInvalidListener;","path":"src/listeners/commandHandler/messageInvalid.js"},"missingPermissions":{"name":"missingPermissions","type":"js","content":"const { Listener } = require('discord-akairo');\r\nconst Logger = require('../../util/Logger');\r\n\r\nclass MissingPermissionsListener extends Listener {\r\n\tconstructor() {\r\n\t\tsuper('missingPermissions', {\r\n\t\t\tevent: 'missingPermissions',\r\n\t\t\temitter: 'commandHandler',\r\n\t\t\tcategory: 'commandHandler'\r\n\t\t});\r\n\t}\r\n\r\n\texec(message, command, type, missing) {\r\n\t\tconst text = {\r\n\t\t\tclient: () => {\r\n\t\t\t\tconst str = this.missingPermissions(message.channel, this.client.user, missing);\r\n\t\t\t\treturn `I'm missing ${str} to use that command.`;\r\n\t\t\t},\r\n\t\t\tuser: () => {\r\n\t\t\t\tconst str = this.missingPermissions(message.channel, message.author, missing);\r\n\t\t\t\treturn `You are missing ${str === undefined ? 'moderator permission' : str} to use that command.`;\r\n\t\t\t}\r\n\t\t}[type];\r\n\r\n\t\tconst tag = message.guild ? `${message.guild.name} :: ${message.author.tag} (${message.author.id})` : `${message.author.tag} (${message.author.id})`;\r\n\t\tLogger.log(`=> ${command.id} ~ ${type}Permissions`, { tag });\r\n\r\n\t\tif (!text) return;\r\n\t\tif (message.guild ? message.channel.permissionsFor(this.client.user).has('SEND_MESSAGES') : true) {\r\n\t\t\tmessage.reply(text());\r\n\t\t}\r\n\t}\r\n\r\n\tmissingPermissions(channel, user, permissions) {\r\n\t\tconst missingPerms = channel.permissionsFor(user).missing(permissions)\r\n\t\t\t.map(str => {\r\n\t\t\t\tif (str === 'VIEW_CHANNEL') return '`Read Messages`';\r\n\t\t\t\tif (str === 'SEND_TTS_MESSAGES') return '`Send TTS Messages`';\r\n\t\t\t\tif (str === 'USE_VAD') return '`Use VAD`';\r\n\t\t\t\treturn `\\`${str.replace(/_/g, ' ').toLowerCase().replace(/\\b(\\w)/g, char => char.toUpperCase())}\\``;\r\n\t\t\t});\r\n\r\n\t\treturn missingPerms.length > 1\r\n\t\t\t? `${missingPerms.slice(0, -1).join(', ')} and ${missingPerms.slice(-1)[0]}`\r\n\t\t\t: missingPerms[0];\r\n\t}\r\n}\r\n\r\nmodule.exports = MissingPermissionsListener;","path":"src/listeners/commandHandler/missingPermissions.js"}}}},"classes":[],"interfaces":[],"typedefs":[],"externals":[]}